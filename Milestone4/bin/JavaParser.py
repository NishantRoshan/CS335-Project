# Generated from JavaParser.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0082")
        buf.write("\u06b8\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\3\2\3\2\3\3\3\3\3\4\3\4\3\4\5\4\u00fc\n\4\3\5\3\5")
        buf.write("\3\5\3\5\3\6\3\6\3\6\7\6\u0105\n\6\f\6\16\6\u0108\13\6")
        buf.write("\3\7\7\7\u010b\n\7\f\7\16\7\u010e\13\7\3\7\3\7\5\7\u0112")
        buf.write("\n\7\3\7\7\7\u0115\n\7\f\7\16\7\u0118\13\7\3\7\3\7\7\7")
        buf.write("\u011c\n\7\f\7\16\7\u011f\13\7\3\b\3\b\3\t\7\t\u0124\n")
        buf.write("\t\f\t\16\t\u0127\13\t\3\t\3\t\3\t\7\t\u012c\n\t\f\t\16")
        buf.write("\t\u012f\13\t\3\t\5\t\u0132\n\t\3\n\3\n\3\n\7\n\u0137")
        buf.write("\n\n\f\n\16\n\u013a\13\n\3\13\3\13\7\13\u013e\n\13\f\13")
        buf.write("\16\13\u0141\13\13\3\13\3\13\3\13\5\13\u0146\n\13\5\13")
        buf.write("\u0148\n\13\3\f\3\f\3\f\3\f\7\f\u014e\n\f\f\f\16\f\u0151")
        buf.write("\13\f\3\f\3\f\3\r\3\r\3\r\5\r\u0158\n\r\3\r\3\r\5\r\u015c")
        buf.write("\n\r\5\r\u015e\n\r\3\16\3\16\3\16\3\16\3\16\5\16\u0165")
        buf.write("\n\16\3\17\3\17\5\17\u0169\n\17\3\17\3\17\3\20\3\20\5")
        buf.write("\20\u016f\n\20\3\20\3\20\7\20\u0173\n\20\f\20\16\20\u0176")
        buf.write("\13\20\3\20\3\20\5\20\u017a\n\20\3\21\3\21\3\21\5\21\u017f")
        buf.write("\n\21\3\21\7\21\u0182\n\21\f\21\16\21\u0185\13\21\3\21")
        buf.write("\3\21\5\21\u0189\n\21\3\22\5\22\u018c\n\22\3\22\7\22\u018f")
        buf.write("\n\22\f\22\16\22\u0192\13\22\3\22\7\22\u0195\n\22\f\22")
        buf.write("\16\22\u0198\13\22\3\22\3\22\3\22\5\22\u019d\n\22\3\23")
        buf.write("\7\23\u01a0\n\23\f\23\16\23\u01a3\13\23\3\23\3\23\3\23")
        buf.write("\3\23\3\24\3\24\5\24\u01ab\n\24\3\24\3\24\3\24\5\24\u01b0")
        buf.write("\n\24\3\24\3\24\3\25\5\25\u01b5\n\25\3\25\3\25\3\25\3")
        buf.write("\25\3\26\7\26\u01bc\n\26\f\26\16\26\u01bf\13\26\3\26\3")
        buf.write("\26\3\26\3\26\3\26\5\26\u01c6\n\26\3\26\5\26\u01c9\n\26")
        buf.write("\3\27\3\27\7\27\u01cd\n\27\f\27\16\27\u01d0\13\27\3\27")
        buf.write("\3\27\3\30\3\30\7\30\u01d6\n\30\f\30\16\30\u01d9\13\30")
        buf.write("\3\30\3\30\3\30\3\30\3\30\3\30\3\30\5\30\u01e2\n\30\3")
        buf.write("\30\3\30\3\30\3\30\3\30\3\30\5\30\u01ea\n\30\3\30\3\30")
        buf.write("\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\5\30")
        buf.write("\u01f8\n\30\3\31\3\31\3\31\3\31\3\31\5\31\u01ff\n\31\3")
        buf.write("\32\3\32\3\33\3\33\3\33\3\33\3\33\3\33\3\33\3\33\3\33")
        buf.write("\3\33\5\33\u020d\n\33\3\34\3\34\3\34\5\34\u0212\n\34\3")
        buf.write("\34\3\34\5\34\u0216\n\34\3\34\3\34\5\34\u021a\n\34\3\34")
        buf.write("\3\34\5\34\u021e\n\34\3\34\3\34\3\35\3\35\3\35\3\35\7")
        buf.write("\35\u0226\n\35\f\35\16\35\u0229\13\35\3\35\3\35\3\36\3")
        buf.write("\36\7\36\u022f\n\36\f\36\16\36\u0232\13\36\3\36\3\36\3")
        buf.write("\37\3\37\5\37\u0238\n\37\3\37\3\37\7\37\u023c\n\37\f\37")
        buf.write("\16\37\u023f\13\37\3\37\5\37\u0242\n\37\3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \5 \u024e\n \3!\3!\3!\3!\3\"\3\"\3\"\7")
        buf.write("\"\u0257\n\"\f\"\16\"\u025a\13\"\3#\3#\3#\5#\u025f\n#")
        buf.write("\3$\3$\3$\7$\u0264\n$\f$\16$\u0267\13$\3%\3%\5%\u026b")
        buf.write("\n%\3&\3&\3&\3&\3&\7&\u0272\n&\f&\16&\u0275\13&\3&\3&")
        buf.write("\5&\u0279\n&\3&\3&\3\'\3\'\3\'\3\'\7\'\u0281\n\'\f\'\16")
        buf.write("\'\u0284\13\'\3\'\3\'\3(\3(\3(\7(\u028b\n(\f(\16(\u028e")
        buf.write("\13(\3(\3(\5(\u0292\n(\3(\5(\u0295\n(\3)\3)\5)\u0299\n")
        buf.write(")\3)\3)\3)\5)\u029e\n)\3)\5)\u02a1\n)\5)\u02a3\n)\3)\3")
        buf.write(")\3*\7*\u02a8\n*\f*\16*\u02ab\13*\3*\3*\3*\3+\3+\5+\u02b2")
        buf.write("\n+\3,\3,\5,\u02b6\n,\3-\3-\3-\3.\3.\3.\3.\5.\u02bf\n")
        buf.write(".\3.\3.\3/\3/\3/\3/\5/\u02c7\n/\3/\3/\5/\u02cb\n/\3/\5")
        buf.write("/\u02ce\n/\3/\5/\u02d1\n/\3/\3/\3\60\3\60\3\60\7\60\u02d8")
        buf.write("\n\60\f\60\16\60\u02db\13\60\3\61\7\61\u02de\n\61\f\61")
        buf.write("\16\61\u02e1\13\61\3\61\3\61\5\61\u02e5\n\61\3\61\5\61")
        buf.write("\u02e8\n\61\3\62\3\62\7\62\u02ec\n\62\f\62\16\62\u02ef")
        buf.write("\13\62\3\63\3\63\3\63\5\63\u02f4\n\63\3\63\3\63\3\63\5")
        buf.write("\63\u02f9\n\63\3\63\3\63\3\64\3\64\5\64\u02ff\n\64\3\64")
        buf.write("\3\64\3\65\3\65\3\65\7\65\u0306\n\65\f\65\16\65\u0309")
        buf.write("\13\65\3\66\3\66\3\66\3\67\3\67\3\67\7\67\u0311\n\67\f")
        buf.write("\67\16\67\u0314\13\67\3\67\3\67\38\78\u0319\n8\f8\168")
        buf.write("\u031c\138\38\38\38\39\39\39\59\u0324\n9\39\39\59\u0328")
        buf.write("\n9\39\39\59\u032c\n9\39\39\3:\3:\7:\u0332\n:\f:\16:\u0335")
        buf.write("\13:\3:\3:\3;\3;\5;\u033b\n;\3<\3<\3<\3=\7=\u0341\n=\f")
        buf.write("=\16=\u0344\13=\3=\3=\5=\u0348\n=\3>\3>\3>\3>\3>\3>\3")
        buf.write(">\3>\5>\u0352\n>\3?\3?\3?\3?\7?\u0358\n?\f?\16?\u035b")
        buf.write("\13?\3?\3?\3@\3@\3@\7@\u0362\n@\f@\16@\u0365\13@\3@\3")
        buf.write("@\3@\3A\7A\u036b\nA\fA\16A\u036e\13A\3A\3A\3B\3B\3B\3")
        buf.write("B\3B\3B\5B\u0378\nB\3C\7C\u037b\nC\fC\16C\u037e\13C\3")
        buf.write("C\3C\3C\3D\7D\u0384\nD\fD\16D\u0387\13D\3D\3D\3D\3D\3")
        buf.write("D\7D\u038e\nD\fD\16D\u0391\13D\3D\3D\5D\u0395\nD\3D\3")
        buf.write("D\3E\3E\3E\3F\3F\3F\7F\u039f\nF\fF\16F\u03a2\13F\3F\3")
        buf.write("F\3F\3G\3G\3G\5G\u03aa\nG\3G\3G\3G\5G\u03af\nG\3G\5G\u03b2")
        buf.write("\nG\3H\3H\3H\7H\u03b7\nH\fH\16H\u03ba\13H\3I\3I\3I\3I")
        buf.write("\3J\3J\3J\5J\u03c3\nJ\3K\3K\3K\3K\7K\u03c9\nK\fK\16K\u03cc")
        buf.write("\13K\5K\u03ce\nK\3K\5K\u03d1\nK\3K\3K\3L\3L\3L\3L\3L\3")
        buf.write("M\3M\7M\u03dc\nM\fM\16M\u03df\13M\3M\3M\3N\7N\u03e4\n")
        buf.write("N\fN\16N\u03e7\13N\3N\3N\5N\u03eb\nN\3O\3O\3O\3O\3O\3")
        buf.write("O\5O\u03f3\nO\3O\3O\5O\u03f7\nO\3O\3O\5O\u03fb\nO\3O\3")
        buf.write("O\5O\u03ff\nO\3O\3O\5O\u0403\nO\5O\u0405\nO\3P\3P\5P\u0409")
        buf.write("\nP\3Q\3Q\3Q\3Q\5Q\u040f\nQ\3R\3R\3S\3S\3S\3S\7S\u0417")
        buf.write("\nS\fS\16S\u041a\13S\3S\5S\u041d\nS\5S\u041f\nS\3S\3S")
        buf.write("\3T\3T\7T\u0425\nT\fT\16T\u0428\13T\3T\3T\3U\3U\3U\3U")
        buf.write("\3U\5U\u0431\nU\3V\7V\u0434\nV\fV\16V\u0437\13V\3V\3V")
        buf.write("\3V\3V\3V\3V\3V\3V\5V\u0441\nV\3W\3W\3W\3W\3W\5W\u0448")
        buf.write("\nW\3W\3W\3W\3W\3W\3W\3W\5W\u0451\nW\3W\3W\3W\3W\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\6W\u0466\nW\r")
        buf.write("W\16W\u0467\3W\5W\u046b\nW\3W\5W\u046e\nW\3W\3W\3W\3W")
        buf.write("\7W\u0474\nW\fW\16W\u0477\13W\3W\5W\u047a\nW\3W\3W\3W")
        buf.write("\3W\7W\u0480\nW\fW\16W\u0483\13W\3W\7W\u0486\nW\fW\16")
        buf.write("W\u0489\13W\3W\3W\3W\3W\3W\3W\3W\3W\5W\u0493\nW\3W\3W")
        buf.write("\3W\3W\3W\3W\3W\5W\u049c\nW\3W\3W\3W\5W\u04a1\nW\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\3W\3W\5W\u04ae\nW\3W\3W\3W\3W\5")
        buf.write("W\u04b4\nW\3X\3X\7X\u04b8\nX\fX\16X\u04bb\13X\5X\u04bd")
        buf.write("\nX\3Y\6Y\u04c0\nY\rY\16Y\u04c1\3Y\6Y\u04c5\nY\rY\16Y")
        buf.write("\u04c6\3Z\3Z\3Z\3Z\3Z\3Z\5Z\u04cf\nZ\3Z\3Z\3Z\5Z\u04d4")
        buf.write("\nZ\3[\3[\5[\u04d8\n[\3\\\3\\\5\\\u04dc\n\\\3\\\3\\\5")
        buf.write("\\\u04e0\n\\\3\\\3\\\5\\\u04e4\n\\\5\\\u04e6\n\\\3]\7")
        buf.write("]\u04e9\n]\f]\16]\u04ec\13]\3]\3]\5]\u04f0\n]\3]\3]\3")
        buf.write("]\3]\3^\3^\3^\7^\u04f9\n^\f^\16^\u04fc\13^\3^\3^\3^\3")
        buf.write("^\3^\3_\3_\3_\7_\u0506\n_\f_\16_\u0509\13_\3`\3`\3`\3")
        buf.write("a\3a\3a\5a\u0511\na\3a\3a\3b\3b\3b\7b\u0518\nb\fb\16b")
        buf.write("\u051b\13b\3c\7c\u051e\nc\fc\16c\u0521\13c\3c\3c\3c\3")
        buf.write("c\3c\5c\u0528\nc\3c\3c\3c\3c\5c\u052e\nc\3d\7d\u0531\n")
        buf.write("d\fd\16d\u0534\13d\3d\3d\7d\u0538\nd\fd\16d\u053b\13d")
        buf.write("\3d\3d\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3e\3")
        buf.write("e\5e\u054f\ne\5e\u0551\ne\3f\3f\3f\3f\3f\3f\3f\5f\u055a")
        buf.write("\nf\3g\3g\3h\3h\3i\3i\3i\5i\u0563\ni\3j\3j\3j\3j\3j\3")
        buf.write("j\3j\7j\u056c\nj\fj\16j\u056f\13j\3j\3j\3j\7j\u0574\n")
        buf.write("j\fj\16j\u0577\13j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\5")
        buf.write("j\u0584\nj\3j\3j\5j\u0588\nj\3j\3j\3j\5j\u058d\nj\3j\3")
        buf.write("j\5j\u0591\nj\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3")
        buf.write("j\5j\u05a1\nj\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3")
        buf.write("j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3")
        buf.write("j\3j\3j\3j\3j\3j\3j\5j\u05c9\nj\3j\3j\3j\3j\5j\u05cf\n")
        buf.write("j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\5j\u05dc\nj\3j\3j\3")
        buf.write("j\5j\u05e1\nj\3j\7j\u05e4\nj\fj\16j\u05e7\13j\3k\3k\3")
        buf.write("k\3k\7k\u05ed\nk\fk\16k\u05f0\13k\3k\3k\3l\3l\3l\3l\5")
        buf.write("l\u05f8\nl\3l\3l\3l\3l\3l\5l\u05ff\nl\3m\3m\3m\7m\u0604")
        buf.write("\nm\fm\16m\u0607\13m\3n\7n\u060a\nn\fn\16n\u060d\13n\3")
        buf.write("n\3n\7n\u0611\nn\fn\16n\u0614\13n\3n\3n\3n\3o\3o\3o\7")
        buf.write("o\u061c\no\fo\16o\u061f\13o\3p\7p\u0622\np\fp\16p\u0625")
        buf.write("\13p\3p\3p\3p\5p\u062a\np\3q\3q\3q\3q\3r\3r\3r\7r\u0633")
        buf.write("\nr\fr\16r\u0636\13r\3s\3s\3s\5s\u063b\ns\3s\3s\3s\3s")
        buf.write("\3s\5s\u0642\ns\3s\3s\3s\3s\5s\u0648\ns\3s\5s\u064b\n")
        buf.write("s\3t\3t\3t\3t\3t\3t\7t\u0653\nt\ft\16t\u0656\13t\3t\3")
        buf.write("t\7t\u065a\nt\ft\16t\u065d\13t\3t\3t\3t\7t\u0662\nt\f")
        buf.write("t\16t\u0665\13t\5t\u0667\nt\3t\3t\3t\7t\u066c\nt\ft\16")
        buf.write("t\u066f\13t\3u\3u\3u\3u\3u\3u\3u\5u\u0678\nu\5u\u067a")
        buf.write("\nu\3v\3v\5v\u067e\nv\3v\3v\3v\5v\u0683\nv\7v\u0685\n")
        buf.write("v\fv\16v\u0688\13v\3v\5v\u068b\nv\3w\3w\5w\u068f\nw\3")
        buf.write("w\3w\3x\3x\3x\3x\7x\u0697\nx\fx\16x\u069a\13x\3x\3x\3")
        buf.write("x\3x\3x\3x\3x\7x\u06a3\nx\fx\16x\u06a6\13x\3x\3x\7x\u06aa")
        buf.write("\nx\fx\16x\u06ad\13x\5x\u06af\nx\3y\3y\5y\u06b3\ny\3z")
        buf.write("\3z\3z\3z\2\4\u00d2\u00e6{\2\4\6\b\n\f\16\20\22\24\26")
        buf.write("\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\")
        buf.write("^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a")
        buf.write("\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c")
        buf.write("\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae")
        buf.write("\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0")
        buf.write("\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2")
        buf.write("\u00d4\u00d6\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4")
        buf.write("\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2\2\22\4\2\65")
        buf.write("C\u0082\u0082\5\2\65>AC\u0082\u0082\n\2\5\5\7\7\n\n\20")
        buf.write("\20\26\26\35\35\37\37\'\'\4\2\23\23**\4\2((>>\3\2NQ\3")
        buf.write("\2RS\3\2il\3\2_`\4\2mnrr\3\2kl\4\2]^de\4\2ccff\4\2\\\\")
        buf.write("s}\3\2ij\4\2bb~~\2\u077a\2\u00f4\3\2\2\2\4\u00f6\3\2\2")
        buf.write("\2\6\u00fb\3\2\2\2\b\u00fd\3\2\2\2\n\u0101\3\2\2\2\f\u010c")
        buf.write("\3\2\2\2\16\u0120\3\2\2\2\20\u0125\3\2\2\2\22\u0133\3")
        buf.write("\2\2\2\24\u0147\3\2\2\2\26\u0149\3\2\2\2\30\u015d\3\2")
        buf.write("\2\2\32\u0164\3\2\2\2\34\u0166\3\2\2\2\36\u0174\3\2\2")
        buf.write("\2 \u017e\3\2\2\2\"\u019c\3\2\2\2$\u01a1\3\2\2\2&\u01a8")
        buf.write("\3\2\2\2(\u01b4\3\2\2\2*\u01c8\3\2\2\2,\u01ca\3\2\2\2")
        buf.write(".\u01f7\3\2\2\2\60\u01fe\3\2\2\2\62\u0200\3\2\2\2\64\u020c")
        buf.write("\3\2\2\2\66\u020e\3\2\2\28\u0221\3\2\2\2:\u022c\3\2\2")
        buf.write("\2<\u0241\3\2\2\2>\u024d\3\2\2\2@\u024f\3\2\2\2B\u0253")
        buf.write("\3\2\2\2D\u025b\3\2\2\2F\u0260\3\2\2\2H\u026a\3\2\2\2")
        buf.write("J\u026c\3\2\2\2L\u027c\3\2\2\2N\u0294\3\2\2\2P\u0296\3")
        buf.write("\2\2\2R\u02a9\3\2\2\2T\u02b1\3\2\2\2V\u02b5\3\2\2\2X\u02b7")
        buf.write("\3\2\2\2Z\u02ba\3\2\2\2\\\u02c2\3\2\2\2^\u02d4\3\2\2\2")
        buf.write("`\u02df\3\2\2\2b\u02e9\3\2\2\2d\u02f0\3\2\2\2f\u02fc\3")
        buf.write("\2\2\2h\u0302\3\2\2\2j\u030a\3\2\2\2l\u030d\3\2\2\2n\u031a")
        buf.write("\3\2\2\2p\u0320\3\2\2\2r\u032f\3\2\2\2t\u033a\3\2\2\2")
        buf.write("v\u033c\3\2\2\2x\u0347\3\2\2\2z\u0351\3\2\2\2|\u0353\3")
        buf.write("\2\2\2~\u035e\3\2\2\2\u0080\u036c\3\2\2\2\u0082\u0377")
        buf.write("\3\2\2\2\u0084\u037c\3\2\2\2\u0086\u0385\3\2\2\2\u0088")
        buf.write("\u0398\3\2\2\2\u008a\u03a0\3\2\2\2\u008c\u03a9\3\2\2\2")
        buf.write("\u008e\u03b3\3\2\2\2\u0090\u03bb\3\2\2\2\u0092\u03c2\3")
        buf.write("\2\2\2\u0094\u03c4\3\2\2\2\u0096\u03d4\3\2\2\2\u0098\u03d9")
        buf.write("\3\2\2\2\u009a\u03ea\3\2\2\2\u009c\u0404\3\2\2\2\u009e")
        buf.write("\u0408\3\2\2\2\u00a0\u040a\3\2\2\2\u00a2\u0410\3\2\2\2")
        buf.write("\u00a4\u0412\3\2\2\2\u00a6\u0422\3\2\2\2\u00a8\u0430\3")
        buf.write("\2\2\2\u00aa\u0435\3\2\2\2\u00ac\u04b3\3\2\2\2\u00ae\u04bc")
        buf.write("\3\2\2\2\u00b0\u04bf\3\2\2\2\u00b2\u04d3\3\2\2\2\u00b4")
        buf.write("\u04d7\3\2\2\2\u00b6\u04e5\3\2\2\2\u00b8\u04ea\3\2\2\2")
        buf.write("\u00ba\u04f5\3\2\2\2\u00bc\u0502\3\2\2\2\u00be\u050a\3")
        buf.write("\2\2\2\u00c0\u050d\3\2\2\2\u00c2\u0514\3\2\2\2\u00c4\u052d")
        buf.write("\3\2\2\2\u00c6\u0532\3\2\2\2\u00c8\u0550\3\2\2\2\u00ca")
        buf.write("\u0559\3\2\2\2\u00cc\u055b\3\2\2\2\u00ce\u055d\3\2\2\2")
        buf.write("\u00d0\u0562\3\2\2\2\u00d2\u0590\3\2\2\2\u00d4\u05e8\3")
        buf.write("\2\2\2\u00d6\u05fe\3\2\2\2\u00d8\u0600\3\2\2\2\u00da\u060b")
        buf.write("\3\2\2\2\u00dc\u0618\3\2\2\2\u00de\u0623\3\2\2\2\u00e0")
        buf.write("\u062b\3\2\2\2\u00e2\u062f\3\2\2\2\u00e4\u064a\3\2\2\2")
        buf.write("\u00e6\u0666\3\2\2\2\u00e8\u0679\3\2\2\2\u00ea\u068a\3")
        buf.write("\2\2\2\u00ec\u068c\3\2\2\2\u00ee\u0692\3\2\2\2\u00f0\u06b0")
        buf.write("\3\2\2\2\u00f2\u06b4\3\2\2\2\u00f4\u00f5\t\2\2\2\u00f5")
        buf.write("\3\3\2\2\2\u00f6\u00f7\t\3\2\2\u00f7\5\3\2\2\2\u00f8\u00f9")
        buf.write("\7^\2\2\u00f9\u00fc\7]\2\2\u00fa\u00fc\5\b\5\2\u00fb\u00f8")
        buf.write("\3\2\2\2\u00fb\u00fa\3\2\2\2\u00fc\7\3\2\2\2\u00fd\u00fe")
        buf.write("\7^\2\2\u00fe\u00ff\5\n\6\2\u00ff\u0100\7]\2\2\u0100\t")
        buf.write("\3\2\2\2\u0101\u0106\5\f\7\2\u0102\u0103\7F\2\2\u0103")
        buf.write("\u0105\5\f\7\2\u0104\u0102\3\2\2\2\u0105\u0108\3\2\2\2")
        buf.write("\u0106\u0104\3\2\2\2\u0106\u0107\3\2\2\2\u0107\13\3\2")
        buf.write("\2\2\u0108\u0106\3\2\2\2\u0109\u010b\5\u008cG\2\u010a")
        buf.write("\u0109\3\2\2\2\u010b\u010e\3\2\2\2\u010c\u010a\3\2\2\2")
        buf.write("\u010c\u010d\3\2\2\2\u010d\u0111\3\2\2\2\u010e\u010c\3")
        buf.write("\2\2\2\u010f\u0112\5\36\20\2\u0110\u0112\5\16\b\2\u0111")
        buf.write("\u010f\3\2\2\2\u0111\u0110\3\2\2\2\u0112\u011d\3\2\2\2")
        buf.write("\u0113\u0115\5\u008cG\2\u0114\u0113\3\2\2\2\u0115\u0118")
        buf.write("\3\2\2\2\u0116\u0114\3\2\2\2\u0116\u0117\3\2\2\2\u0117")
        buf.write("\u0119\3\2\2\2\u0118\u0116\3\2\2\2\u0119\u011a\7L\2\2")
        buf.write("\u011a\u011c\7M\2\2\u011b\u0116\3\2\2\2\u011c\u011f\3")
        buf.write("\2\2\2\u011d\u011b\3\2\2\2\u011d\u011e\3\2\2\2\u011e\r")
        buf.write("\3\2\2\2\u011f\u011d\3\2\2\2\u0120\u0121\t\4\2\2\u0121")
        buf.write("\17\3\2\2\2\u0122\u0124\5\u008cG\2\u0123\u0122\3\2\2\2")
        buf.write("\u0124\u0127\3\2\2\2\u0125\u0123\3\2\2\2\u0125\u0126\3")
        buf.write("\2\2\2\u0126\u0128\3\2\2\2\u0127\u0125\3\2\2\2\u0128\u0131")
        buf.write("\5\2\2\2\u0129\u012d\7\23\2\2\u012a\u012c\5\u008cG\2\u012b")
        buf.write("\u012a\3\2\2\2\u012c\u012f\3\2\2\2\u012d\u012b\3\2\2\2")
        buf.write("\u012d\u012e\3\2\2\2\u012e\u0130\3\2\2\2\u012f\u012d\3")
        buf.write("\2\2\2\u0130\u0132\5\22\n\2\u0131\u0129\3\2\2\2\u0131")
        buf.write("\u0132\3\2\2\2\u0132\21\3\2\2\2\u0133\u0138\5\f\7\2\u0134")
        buf.write("\u0135\7o\2\2\u0135\u0137\5\f\7\2\u0136\u0134\3\2\2\2")
        buf.write("\u0137\u013a\3\2\2\2\u0138\u0136\3\2\2\2\u0138\u0139\3")
        buf.write("\2\2\2\u0139\23\3\2\2\2\u013a\u0138\3\2\2\2\u013b\u0148")
        buf.write("\5\f\7\2\u013c\u013e\5\u008cG\2\u013d\u013c\3\2\2\2\u013e")
        buf.write("\u0141\3\2\2\2\u013f\u013d\3\2\2\2\u013f\u0140\3\2\2\2")
        buf.write("\u0140\u0142\3\2\2\2\u0141\u013f\3\2\2\2\u0142\u0145\7")
        buf.write("a\2\2\u0143\u0144\t\5\2\2\u0144\u0146\5\f\7\2\u0145\u0143")
        buf.write("\3\2\2\2\u0145\u0146\3\2\2\2\u0146\u0148\3\2\2\2\u0147")
        buf.write("\u013b\3\2\2\2\u0147\u013f\3\2\2\2\u0148\25\3\2\2\2\u0149")
        buf.write("\u014a\7^\2\2\u014a\u014f\5\24\13\2\u014b\u014c\7F\2\2")
        buf.write("\u014c\u014e\5\24\13\2\u014d\u014b\3\2\2\2\u014e\u0151")
        buf.write("\3\2\2\2\u014f\u014d\3\2\2\2\u014f\u0150\3\2\2\2\u0150")
        buf.write("\u0152\3\2\2\2\u0151\u014f\3\2\2\2\u0152\u0153\7]\2\2")
        buf.write("\u0153\27\3\2\2\2\u0154\u015e\5\34\17\2\u0155\u0157\7")
        buf.write("G\2\2\u0156\u0158\5\26\f\2\u0157\u0156\3\2\2\2\u0157\u0158")
        buf.write("\3\2\2\2\u0158\u0159\3\2\2\2\u0159\u015b\5\2\2\2\u015a")
        buf.write("\u015c\5\34\17\2\u015b\u015a\3\2\2\2\u015b\u015c\3\2\2")
        buf.write("\2\u015c\u015e\3\2\2\2\u015d\u0154\3\2\2\2\u015d\u0155")
        buf.write("\3\2\2\2\u015e\31\3\2\2\2\u015f\u0160\7*\2\2\u0160\u0165")
        buf.write("\5\30\r\2\u0161\u0162\5\2\2\2\u0162\u0163\5\34\17\2\u0163")
        buf.write("\u0165\3\2\2\2\u0164\u015f\3\2\2\2\u0164\u0161\3\2\2\2")
        buf.write("\u0165\33\3\2\2\2\u0166\u0168\7H\2\2\u0167\u0169\5\u00e2")
        buf.write("r\2\u0168\u0167\3\2\2\2\u0168\u0169\3\2\2\2\u0169\u016a")
        buf.write("\3\2\2\2\u016a\u016b\7I\2\2\u016b\35\3\2\2\2\u016c\u016e")
        buf.write("\5\2\2\2\u016d\u016f\5\26\f\2\u016e\u016d\3\2\2\2\u016e")
        buf.write("\u016f\3\2\2\2\u016f\u0170\3\2\2\2\u0170\u0171\7G\2\2")
        buf.write("\u0171\u0173\3\2\2\2\u0172\u016c\3\2\2\2\u0173\u0176\3")
        buf.write("\2\2\2\u0174\u0172\3\2\2\2\u0174\u0175\3\2\2\2\u0175\u0177")
        buf.write("\3\2\2\2\u0176\u0174\3\2\2\2\u0177\u0179\5\4\3\2\u0178")
        buf.write("\u017a\5\26\f\2\u0179\u0178\3\2\2\2\u0179\u017a\3\2\2")
        buf.write("\2\u017a\37\3\2\2\2\u017b\u017c\5\36\20\2\u017c\u017d")
        buf.write("\7G\2\2\u017d\u017f\3\2\2\2\u017e\u017b\3\2\2\2\u017e")
        buf.write("\u017f\3\2\2\2\u017f\u0183\3\2\2\2\u0180\u0182\5\u008c")
        buf.write("G\2\u0181\u0180\3\2\2\2\u0182\u0185\3\2\2\2\u0183\u0181")
        buf.write("\3\2\2\2\u0183\u0184\3\2\2\2\u0184\u0186\3\2\2\2\u0185")
        buf.write("\u0183\3\2\2\2\u0186\u0188\5\2\2\2\u0187\u0189\5\26\f")
        buf.write("\2\u0188\u0187\3\2\2\2\u0188\u0189\3\2\2\2\u0189!\3\2")
        buf.write("\2\2\u018a\u018c\5$\23\2\u018b\u018a\3\2\2\2\u018b\u018c")
        buf.write("\3\2\2\2\u018c\u0190\3\2\2\2\u018d\u018f\5&\24\2\u018e")
        buf.write("\u018d\3\2\2\2\u018f\u0192\3\2\2\2\u0190\u018e\3\2\2\2")
        buf.write("\u0190\u0191\3\2\2\2\u0191\u0196\3\2\2\2\u0192\u0190\3")
        buf.write("\2\2\2\u0193\u0195\5*\26\2\u0194\u0193\3\2\2\2\u0195\u0198")
        buf.write("\3\2\2\2\u0196\u0194\3\2\2\2\u0196\u0197\3\2\2\2\u0197")
        buf.write("\u019d\3\2\2\2\u0198\u0196\3\2\2\2\u0199\u019a\5(\25\2")
        buf.write("\u019a\u019b\7\2\2\3\u019b\u019d\3\2\2\2\u019c\u018b\3")
        buf.write("\2\2\2\u019c\u0199\3\2\2\2\u019d#\3\2\2\2\u019e\u01a0")
        buf.write("\5\u008cG\2\u019f\u019e\3\2\2\2\u01a0\u01a3\3\2\2\2\u01a1")
        buf.write("\u019f\3\2\2\2\u01a1\u01a2\3\2\2\2\u01a2\u01a4\3\2\2\2")
        buf.write("\u01a3\u01a1\3\2\2\2\u01a4\u01a5\7\"\2\2\u01a5\u01a6\5")
        buf.write("\u00dco\2\u01a6\u01a7\7E\2\2\u01a7%\3\2\2\2\u01a8\u01aa")
        buf.write("\7\33\2\2\u01a9\u01ab\7(\2\2\u01aa\u01a9\3\2\2\2\u01aa")
        buf.write("\u01ab\3\2\2\2\u01ab\u01ac\3\2\2\2\u01ac\u01af\5\u00dc")
        buf.write("o\2\u01ad\u01ae\7G\2\2\u01ae\u01b0\7m\2\2\u01af\u01ad")
        buf.write("\3\2\2\2\u01af\u01b0\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1")
        buf.write("\u01b2\7E\2\2\u01b2\'\3\2\2\2\u01b3\u01b5\7\66\2\2\u01b4")
        buf.write("\u01b3\3\2\2\2\u01b4\u01b5\3\2\2\2\u01b5\u01b6\3\2\2\2")
        buf.write("\u01b6\u01b7\7\65\2\2\u01b7\u01b8\5\u00dco\2\u01b8\u01b9")
        buf.write("\5,\27\2\u01b9)\3\2\2\2\u01ba\u01bc\5\64\33\2\u01bb\u01ba")
        buf.write("\3\2\2\2\u01bc\u01bf\3\2\2\2\u01bd\u01bb\3\2\2\2\u01bd")
        buf.write("\u01be\3\2\2\2\u01be\u01c5\3\2\2\2\u01bf\u01bd\3\2\2\2")
        buf.write("\u01c0\u01c6\5\66\34\2\u01c1\u01c6\5\\/\2\u01c2\u01c6")
        buf.write("\5p9\2\u01c3\u01c6\5\u0096L\2\u01c4\u01c6\5d\63\2\u01c5")
        buf.write("\u01c0\3\2\2\2\u01c5\u01c1\3\2\2\2\u01c5\u01c2\3\2\2\2")
        buf.write("\u01c5\u01c3\3\2\2\2\u01c5\u01c4\3\2\2\2\u01c6\u01c9\3")
        buf.write("\2\2\2\u01c7\u01c9\7E\2\2\u01c8\u01bd\3\2\2\2\u01c8\u01c7")
        buf.write("\3\2\2\2\u01c9+\3\2\2\2\u01ca\u01ce\7J\2\2\u01cb\u01cd")
        buf.write("\5.\30\2\u01cc\u01cb\3\2\2\2\u01cd\u01d0\3\2\2\2\u01ce")
        buf.write("\u01cc\3\2\2\2\u01ce\u01cf\3\2\2\2\u01cf\u01d1\3\2\2\2")
        buf.write("\u01d0\u01ce\3\2\2\2\u01d1\u01d2\7K\2\2\u01d2-\3\2\2\2")
        buf.write("\u01d3\u01d7\7\67\2\2\u01d4\u01d6\5\62\32\2\u01d5\u01d4")
        buf.write("\3\2\2\2\u01d6\u01d9\3\2\2\2\u01d7\u01d5\3\2\2\2\u01d7")
        buf.write("\u01d8\3\2\2\2\u01d8\u01da\3\2\2\2\u01d9\u01d7\3\2\2\2")
        buf.write("\u01da\u01db\5\u00dco\2\u01db\u01dc\7E\2\2\u01dc\u01f8")
        buf.write("\3\2\2\2\u01dd\u01de\78\2\2\u01de\u01e1\5\u00dco\2\u01df")
        buf.write("\u01e0\7:\2\2\u01e0\u01e2\5\u00dco\2\u01e1\u01df\3\2\2")
        buf.write("\2\u01e1\u01e2\3\2\2\2\u01e2\u01e3\3\2\2\2\u01e3\u01e4")
        buf.write("\7E\2\2\u01e4\u01f8\3\2\2\2\u01e5\u01e6\79\2\2\u01e6\u01e9")
        buf.write("\5\u00dco\2\u01e7\u01e8\7:\2\2\u01e8\u01ea\5\u00dco\2")
        buf.write("\u01e9\u01e7\3\2\2\2\u01e9\u01ea\3\2\2\2\u01ea\u01eb\3")
        buf.write("\2\2\2\u01eb\u01ec\7E\2\2\u01ec\u01f8\3\2\2\2\u01ed\u01ee")
        buf.write("\7;\2\2\u01ee\u01ef\5\u00dco\2\u01ef\u01f0\7E\2\2\u01f0")
        buf.write("\u01f8\3\2\2\2\u01f1\u01f2\7<\2\2\u01f2\u01f3\5\u00dc")
        buf.write("o\2\u01f3\u01f4\7=\2\2\u01f4\u01f5\5\u00dco\2\u01f5\u01f6")
        buf.write("\7E\2\2\u01f6\u01f8\3\2\2\2\u01f7\u01d3\3\2\2\2\u01f7")
        buf.write("\u01dd\3\2\2\2\u01f7\u01e5\3\2\2\2\u01f7\u01ed\3\2\2\2")
        buf.write("\u01f7\u01f1\3\2\2\2\u01f8/\3\2\2\2\u01f9\u01ff\5\64\33")
        buf.write("\2\u01fa\u01ff\7 \2\2\u01fb\u01ff\7,\2\2\u01fc\u01ff\7")
        buf.write("\60\2\2\u01fd\u01ff\7\63\2\2\u01fe\u01f9\3\2\2\2\u01fe")
        buf.write("\u01fa\3\2\2\2\u01fe\u01fb\3\2\2\2\u01fe\u01fc\3\2\2\2")
        buf.write("\u01fe\u01fd\3\2\2\2\u01ff\61\3\2\2\2\u0200\u0201\t\6")
        buf.write("\2\2\u0201\63\3\2\2\2\u0202\u020d\5\u008cG\2\u0203\u020d")
        buf.write("\7%\2\2\u0204\u020d\7$\2\2\u0205\u020d\7#\2\2\u0206\u020d")
        buf.write("\7(\2\2\u0207\u020d\7\3\2\2\u0208\u020d\7\24\2\2\u0209")
        buf.write("\u020d\7)\2\2\u020a\u020d\7B\2\2\u020b\u020d\7D\2\2\u020c")
        buf.write("\u0202\3\2\2\2\u020c\u0203\3\2\2\2\u020c\u0204\3\2\2\2")
        buf.write("\u020c\u0205\3\2\2\2\u020c\u0206\3\2\2\2\u020c\u0207\3")
        buf.write("\2\2\2\u020c\u0208\3\2\2\2\u020c\u0209\3\2\2\2\u020c\u020a")
        buf.write("\3\2\2\2\u020c\u020b\3\2\2\2\u020d\65\3\2\2\2\u020e\u020f")
        buf.write("\7\13\2\2\u020f\u0211\5\2\2\2\u0210\u0212\58\35\2\u0211")
        buf.write("\u0210\3\2\2\2\u0211\u0212\3\2\2\2\u0212\u0215\3\2\2\2")
        buf.write("\u0213\u0214\7\23\2\2\u0214\u0216\5\f\7\2\u0215\u0213")
        buf.write("\3\2\2\2\u0215\u0216\3\2\2\2\u0216\u0219\3\2\2\2\u0217")
        buf.write("\u0218\7\32\2\2\u0218\u021a\5\n\6\2\u0219\u0217\3\2\2")
        buf.write("\2\u0219\u021a\3\2\2\2\u021a\u021d\3\2\2\2\u021b\u021c")
        buf.write("\7C\2\2\u021c\u021e\5\n\6\2\u021d\u021b\3\2\2\2\u021d")
        buf.write("\u021e\3\2\2\2\u021e\u021f\3\2\2\2\u021f\u0220\5:\36\2")
        buf.write("\u0220\67\3\2\2\2\u0221\u0222\7^\2\2\u0222\u0227\5\20")
        buf.write("\t\2\u0223\u0224\7F\2\2\u0224\u0226\5\20\t\2\u0225\u0223")
        buf.write("\3\2\2\2\u0226\u0229\3\2\2\2\u0227\u0225\3\2\2\2\u0227")
        buf.write("\u0228\3\2\2\2\u0228\u022a\3\2\2\2\u0229\u0227\3\2\2\2")
        buf.write("\u022a\u022b\7]\2\2\u022b9\3\2\2\2\u022c\u0230\7J\2\2")
        buf.write("\u022d\u022f\5<\37\2\u022e\u022d\3\2\2\2\u022f\u0232\3")
        buf.write("\2\2\2\u0230\u022e\3\2\2\2\u0230\u0231\3\2\2\2\u0231\u0233")
        buf.write("\3\2\2\2\u0232\u0230\3\2\2\2\u0233\u0234\7K\2\2\u0234")
        buf.write(";\3\2\2\2\u0235\u0242\7E\2\2\u0236\u0238\7(\2\2\u0237")
        buf.write("\u0236\3\2\2\2\u0237\u0238\3\2\2\2\u0238\u0239\3\2\2\2")
        buf.write("\u0239\u0242\5\u00a6T\2\u023a\u023c\5\60\31\2\u023b\u023a")
        buf.write("\3\2\2\2\u023c\u023f\3\2\2\2\u023d\u023b\3\2\2\2\u023d")
        buf.write("\u023e\3\2\2\2\u023e\u0240\3\2\2\2\u023f\u023d\3\2\2\2")
        buf.write("\u0240\u0242\5> \2\u0241\u0235\3\2\2\2\u0241\u0237\3\2")
        buf.write("\2\2\u0241\u023d\3\2\2\2\u0242=\3\2\2\2\u0243\u024e\5")
        buf.write("d\63\2\u0244\u024e\5J&\2\u0245\u024e\5v<\2\u0246\u024e")
        buf.write("\5@!\2\u0247\u024e\5Z.\2\u0248\u024e\5X-\2\u0249\u024e")
        buf.write("\5p9\2\u024a\u024e\5\u0096L\2\u024b\u024e\5\66\34\2\u024c")
        buf.write("\u024e\5\\/\2\u024d\u0243\3\2\2\2\u024d\u0244\3\2\2\2")
        buf.write("\u024d\u0245\3\2\2\2\u024d\u0246\3\2\2\2\u024d\u0247\3")
        buf.write("\2\2\2\u024d\u0248\3\2\2\2\u024d\u0249\3\2\2\2\u024d\u024a")
        buf.write("\3\2\2\2\u024d\u024b\3\2\2\2\u024d\u024c\3\2\2\2\u024e")
        buf.write("?\3\2\2\2\u024f\u0250\5\f\7\2\u0250\u0251\5B\"\2\u0251")
        buf.write("\u0252\7E\2\2\u0252A\3\2\2\2\u0253\u0258\5D#\2\u0254\u0255")
        buf.write("\7F\2\2\u0255\u0257\5D#\2\u0256\u0254\3\2\2\2\u0257\u025a")
        buf.write("\3\2\2\2\u0258\u0256\3\2\2\2\u0258\u0259\3\2\2\2\u0259")
        buf.write("C\3\2\2\2\u025a\u0258\3\2\2\2\u025b\u025e\5F$\2\u025c")
        buf.write("\u025d\7\\\2\2\u025d\u025f\5H%\2\u025e\u025c\3\2\2\2\u025e")
        buf.write("\u025f\3\2\2\2\u025fE\3\2\2\2\u0260\u0265\5\2\2\2\u0261")
        buf.write("\u0262\7L\2\2\u0262\u0264\7M\2\2\u0263\u0261\3\2\2\2\u0264")
        buf.write("\u0267\3\2\2\2\u0265\u0263\3\2\2\2\u0265\u0266\3\2\2\2")
        buf.write("\u0266G\3\2\2\2\u0267\u0265\3\2\2\2\u0268\u026b\5\u00a4")
        buf.write("S\2\u0269\u026b\5\u00d2j\2\u026a\u0268\3\2\2\2\u026a\u0269")
        buf.write("\3\2\2\2\u026bI\3\2\2\2\u026c\u026d\5t;\2\u026d\u026e")
        buf.write("\5\2\2\2\u026e\u0273\5P)\2\u026f\u0270\7L\2\2\u0270\u0272")
        buf.write("\7M\2\2\u0271\u026f\3\2\2\2\u0272\u0275\3\2\2\2\u0273")
        buf.write("\u0271\3\2\2\2\u0273\u0274\3\2\2\2\u0274\u0278\3\2\2\2")
        buf.write("\u0275\u0273\3\2\2\2\u0276\u0277\7/\2\2\u0277\u0279\5")
        buf.write("\u00d8m\2\u0278\u0276\3\2\2\2\u0278\u0279\3\2\2\2\u0279")
        buf.write("\u027a\3\2\2\2\u027a\u027b\5V,\2\u027bK\3\2\2\2\u027c")
        buf.write("\u0282\5\f\7\2\u027d\u027e\5\2\2\2\u027e\u027f\7G\2\2")
        buf.write("\u027f\u0281\3\2\2\2\u0280\u027d\3\2\2\2\u0281\u0284\3")
        buf.write("\2\2\2\u0282\u0280\3\2\2\2\u0282\u0283\3\2\2\2\u0283\u0285")
        buf.write("\3\2\2\2\u0284\u0282\3\2\2\2\u0285\u0286\7-\2\2\u0286")
        buf.write("M\3\2\2\2\u0287\u028c\5R*\2\u0288\u0289\7F\2\2\u0289\u028b")
        buf.write("\5R*\2\u028a\u0288\3\2\2\2\u028b\u028e\3\2\2\2\u028c\u028a")
        buf.write("\3\2\2\2\u028c\u028d\3\2\2\2\u028d\u0291\3\2\2\2\u028e")
        buf.write("\u028c\3\2\2\2\u028f\u0290\7F\2\2\u0290\u0292\5\u00da")
        buf.write("n\2\u0291\u028f\3\2\2\2\u0291\u0292\3\2\2\2\u0292\u0295")
        buf.write("\3\2\2\2\u0293\u0295\5\u00dan\2\u0294\u0287\3\2\2\2\u0294")
        buf.write("\u0293\3\2\2\2\u0295O\3\2\2\2\u0296\u02a2\7H\2\2\u0297")
        buf.write("\u0299\5L\'\2\u0298\u0297\3\2\2\2\u0298\u0299\3\2\2\2")
        buf.write("\u0299\u02a3\3\2\2\2\u029a\u029d\5L\'\2\u029b\u029c\7")
        buf.write("F\2\2\u029c\u029e\5N(\2\u029d\u029b\3\2\2\2\u029d\u029e")
        buf.write("\3\2\2\2\u029e\u02a3\3\2\2\2\u029f\u02a1\5N(\2\u02a0\u029f")
        buf.write("\3\2\2\2\u02a0\u02a1\3\2\2\2\u02a1\u02a3\3\2\2\2\u02a2")
        buf.write("\u0298\3\2\2\2\u02a2\u029a\3\2\2\2\u02a2\u02a0\3\2\2\2")
        buf.write("\u02a3\u02a4\3\2\2\2\u02a4\u02a5\7I\2\2\u02a5Q\3\2\2\2")
        buf.write("\u02a6\u02a8\5T+\2\u02a7\u02a6\3\2\2\2\u02a8\u02ab\3\2")
        buf.write("\2\2\u02a9\u02a7\3\2\2\2\u02a9\u02aa\3\2\2\2\u02aa\u02ac")
        buf.write("\3\2\2\2\u02ab\u02a9\3\2\2\2\u02ac\u02ad\5\f\7\2\u02ad")
        buf.write("\u02ae\5F$\2\u02aeS\3\2\2\2\u02af\u02b2\7\24\2\2\u02b0")
        buf.write("\u02b2\5\u008cG\2\u02b1\u02af\3\2\2\2\u02b1\u02b0\3\2")
        buf.write("\2\2\u02b2U\3\2\2\2\u02b3\u02b6\5\u00a6T\2\u02b4\u02b6")
        buf.write("\7E\2\2\u02b5\u02b3\3\2\2\2\u02b5\u02b4\3\2\2\2\u02b6")
        buf.write("W\3\2\2\2\u02b7\u02b8\58\35\2\u02b8\u02b9\5Z.\2\u02b9")
        buf.write("Y\3\2\2\2\u02ba\u02bb\5\2\2\2\u02bb\u02be\5P)\2\u02bc")
        buf.write("\u02bd\7/\2\2\u02bd\u02bf\5\u00d8m\2\u02be\u02bc\3\2\2")
        buf.write("\2\u02be\u02bf\3\2\2\2\u02bf\u02c0\3\2\2\2\u02c0\u02c1")
        buf.write("\5\u00a6T\2\u02c1[\3\2\2\2\u02c2\u02c3\7\22\2\2\u02c3")
        buf.write("\u02c6\5\2\2\2\u02c4\u02c5\7\32\2\2\u02c5\u02c7\5\n\6")
        buf.write("\2\u02c6\u02c4\3\2\2\2\u02c6\u02c7\3\2\2\2\u02c7\u02c8")
        buf.write("\3\2\2\2\u02c8\u02ca\7J\2\2\u02c9\u02cb\5^\60\2\u02ca")
        buf.write("\u02c9\3\2\2\2\u02ca\u02cb\3\2\2\2\u02cb\u02cd\3\2\2\2")
        buf.write("\u02cc\u02ce\7F\2\2\u02cd\u02cc\3\2\2\2\u02cd\u02ce\3")
        buf.write("\2\2\2\u02ce\u02d0\3\2\2\2\u02cf\u02d1\5b\62\2\u02d0\u02cf")
        buf.write("\3\2\2\2\u02d0\u02d1\3\2\2\2\u02d1\u02d2\3\2\2\2\u02d2")
        buf.write("\u02d3\7K\2\2\u02d3]\3\2\2\2\u02d4\u02d9\5`\61\2\u02d5")
        buf.write("\u02d6\7F\2\2\u02d6\u02d8\5`\61\2\u02d7\u02d5\3\2\2\2")
        buf.write("\u02d8\u02db\3\2\2\2\u02d9\u02d7\3\2\2\2\u02d9\u02da\3")
        buf.write("\2\2\2\u02da_\3\2\2\2\u02db\u02d9\3\2\2\2\u02dc\u02de")
        buf.write("\5\u008cG\2\u02dd\u02dc\3\2\2\2\u02de\u02e1\3\2\2\2\u02df")
        buf.write("\u02dd\3\2\2\2\u02df\u02e0\3\2\2\2\u02e0\u02e2\3\2\2\2")
        buf.write("\u02e1\u02df\3\2\2\2\u02e2\u02e4\5\2\2\2\u02e3\u02e5\5")
        buf.write("\34\17\2\u02e4\u02e3\3\2\2\2\u02e4\u02e5\3\2\2\2\u02e5")
        buf.write("\u02e7\3\2\2\2\u02e6\u02e8\5:\36\2\u02e7\u02e6\3\2\2\2")
        buf.write("\u02e7\u02e8\3\2\2\2\u02e8a\3\2\2\2\u02e9\u02ed\7E\2\2")
        buf.write("\u02ea\u02ec\5<\37\2\u02eb\u02ea\3\2\2\2\u02ec\u02ef\3")
        buf.write("\2\2\2\u02ed\u02eb\3\2\2\2\u02ed\u02ee\3\2\2\2\u02eec")
        buf.write("\3\2\2\2\u02ef\u02ed\3\2\2\2\u02f0\u02f1\7A\2\2\u02f1")
        buf.write("\u02f3\5\2\2\2\u02f2\u02f4\58\35\2\u02f3\u02f2\3\2\2\2")
        buf.write("\u02f3\u02f4\3\2\2\2\u02f4\u02f5\3\2\2\2\u02f5\u02f8\5")
        buf.write("f\64\2\u02f6\u02f7\7\32\2\2\u02f7\u02f9\5\n\6\2\u02f8")
        buf.write("\u02f6\3\2\2\2\u02f8\u02f9\3\2\2\2\u02f9\u02fa\3\2\2\2")
        buf.write("\u02fa\u02fb\5l\67\2\u02fbe\3\2\2\2\u02fc\u02fe\7H\2\2")
        buf.write("\u02fd\u02ff\5h\65\2\u02fe\u02fd\3\2\2\2\u02fe\u02ff\3")
        buf.write("\2\2\2\u02ff\u0300\3\2\2\2\u0300\u0301\7I\2\2\u0301g\3")
        buf.write("\2\2\2\u0302\u0307\5j\66\2\u0303\u0304\7F\2\2\u0304\u0306")
        buf.write("\5j\66\2\u0305\u0303\3\2\2\2\u0306\u0309\3\2\2\2\u0307")
        buf.write("\u0305\3\2\2\2\u0307\u0308\3\2\2\2\u0308i\3\2\2\2\u0309")
        buf.write("\u0307\3\2\2\2\u030a\u030b\5\f\7\2\u030b\u030c\5\2\2\2")
        buf.write("\u030ck\3\2\2\2\u030d\u0312\7J\2\2\u030e\u0311\5<\37\2")
        buf.write("\u030f\u0311\5n8\2\u0310\u030e\3\2\2\2\u0310\u030f\3\2")
        buf.write("\2\2\u0311\u0314\3\2\2\2\u0312\u0310\3\2\2\2\u0312\u0313")
        buf.write("\3\2\2\2\u0313\u0315\3\2\2\2\u0314\u0312\3\2\2\2\u0315")
        buf.write("\u0316\7K\2\2\u0316m\3\2\2\2\u0317\u0319\5\60\31\2\u0318")
        buf.write("\u0317\3\2\2\2\u0319\u031c\3\2\2\2\u031a\u0318\3\2\2\2")
        buf.write("\u031a\u031b\3\2\2\2\u031b\u031d\3\2\2\2\u031c\u031a\3")
        buf.write("\2\2\2\u031d\u031e\5\2\2\2\u031e\u031f\5\u00a6T\2\u031f")
        buf.write("o\3\2\2\2\u0320\u0321\7\36\2\2\u0321\u0323\5\2\2\2\u0322")
        buf.write("\u0324\58\35\2\u0323\u0322\3\2\2\2\u0323\u0324\3\2\2\2")
        buf.write("\u0324\u0327\3\2\2\2\u0325\u0326\7\23\2\2\u0326\u0328")
        buf.write("\5\n\6\2\u0327\u0325\3\2\2\2\u0327\u0328\3\2\2\2\u0328")
        buf.write("\u032b\3\2\2\2\u0329\u032a\7C\2\2\u032a\u032c\5\n\6\2")
        buf.write("\u032b\u0329\3\2\2\2\u032b\u032c\3\2\2\2\u032c\u032d\3")
        buf.write("\2\2\2\u032d\u032e\5r:\2\u032eq\3\2\2\2\u032f\u0333\7")
        buf.write("J\2\2\u0330\u0332\5x=\2\u0331\u0330\3\2\2\2\u0332\u0335")
        buf.write("\3\2\2\2\u0333\u0331\3\2\2\2\u0333\u0334\3\2\2\2\u0334")
        buf.write("\u0336\3\2\2\2\u0335\u0333\3\2\2\2\u0336\u0337\7K\2\2")
        buf.write("\u0337s\3\2\2\2\u0338\u033b\5\f\7\2\u0339\u033b\7\62\2")
        buf.write("\2\u033a\u0338\3\2\2\2\u033a\u0339\3\2\2\2\u033bu\3\2")
        buf.write("\2\2\u033c\u033d\58\35\2\u033d\u033e\5J&\2\u033ew\3\2")
        buf.write("\2\2\u033f\u0341\5\60\31\2\u0340\u033f\3\2\2\2\u0341\u0344")
        buf.write("\3\2\2\2\u0342\u0340\3\2\2\2\u0342\u0343\3\2\2\2\u0343")
        buf.write("\u0345\3\2\2\2\u0344\u0342\3\2\2\2\u0345\u0348\5z>\2\u0346")
        buf.write("\u0348\7E\2\2\u0347\u0342\3\2\2\2\u0347\u0346\3\2\2\2")
        buf.write("\u0348y\3\2\2\2\u0349\u0352\5|?\2\u034a\u0352\5\u0080")
        buf.write("A\2\u034b\u0352\5\u0084C\2\u034c\u0352\5p9\2\u034d\u0352")
        buf.write("\5\u0096L\2\u034e\u0352\5\66\34\2\u034f\u0352\5\\/\2\u0350")
        buf.write("\u0352\5d\63\2\u0351\u0349\3\2\2\2\u0351\u034a\3\2\2\2")
        buf.write("\u0351\u034b\3\2\2\2\u0351\u034c\3\2\2\2\u0351\u034d\3")
        buf.write("\2\2\2\u0351\u034e\3\2\2\2\u0351\u034f\3\2\2\2\u0351\u0350")
        buf.write("\3\2\2\2\u0352{\3\2\2\2\u0353\u0354\5\f\7\2\u0354\u0359")
        buf.write("\5~@\2\u0355\u0356\7F\2\2\u0356\u0358\5~@\2\u0357\u0355")
        buf.write("\3\2\2\2\u0358\u035b\3\2\2\2\u0359\u0357\3\2\2\2\u0359")
        buf.write("\u035a\3\2\2\2\u035a\u035c\3\2\2\2\u035b\u0359\3\2\2\2")
        buf.write("\u035c\u035d\7E\2\2\u035d}\3\2\2\2\u035e\u0363\5\2\2\2")
        buf.write("\u035f\u0360\7L\2\2\u0360\u0362\7M\2\2\u0361\u035f\3\2")
        buf.write("\2\2\u0362\u0365\3\2\2\2\u0363\u0361\3\2\2\2\u0363\u0364")
        buf.write("\3\2\2\2\u0364\u0366\3\2\2\2\u0365\u0363\3\2\2\2\u0366")
        buf.write("\u0367\7\\\2\2\u0367\u0368\5H%\2\u0368\177\3\2\2\2\u0369")
        buf.write("\u036b\5\u0082B\2\u036a\u0369\3\2\2\2\u036b\u036e\3\2")
        buf.write("\2\2\u036c\u036a\3\2\2\2\u036c\u036d\3\2\2\2\u036d\u036f")
        buf.write("\3\2\2\2\u036e\u036c\3\2\2\2\u036f\u0370\5\u0086D\2\u0370")
        buf.write("\u0081\3\2\2\2\u0371\u0378\5\u008cG\2\u0372\u0378\7%\2")
        buf.write("\2\u0373\u0378\7\3\2\2\u0374\u0378\7\16\2\2\u0375\u0378")
        buf.write("\7(\2\2\u0376\u0378\7)\2\2\u0377\u0371\3\2\2\2\u0377\u0372")
        buf.write("\3\2\2\2\u0377\u0373\3\2\2\2\u0377\u0374\3\2\2\2\u0377")
        buf.write("\u0375\3\2\2\2\u0377\u0376\3\2\2\2\u0378\u0083\3\2\2\2")
        buf.write("\u0379\u037b\5\u0082B\2\u037a\u0379\3\2\2\2\u037b\u037e")
        buf.write("\3\2\2\2\u037c\u037a\3\2\2\2\u037c\u037d\3\2\2\2\u037d")
        buf.write("\u037f\3\2\2\2\u037e\u037c\3\2\2\2\u037f\u0380\58\35\2")
        buf.write("\u0380\u0381\5\u0086D\2\u0381\u0085\3\2\2\2\u0382\u0384")
        buf.write("\5\u008cG\2\u0383\u0382\3\2\2\2\u0384\u0387\3\2\2\2\u0385")
        buf.write("\u0383\3\2\2\2\u0385\u0386\3\2\2\2\u0386\u0388\3\2\2\2")
        buf.write("\u0387\u0385\3\2\2\2\u0388\u0389\5t;\2\u0389\u038a\5\2")
        buf.write("\2\2\u038a\u038f\5P)\2\u038b\u038c\7L\2\2\u038c\u038e")
        buf.write("\7M\2\2\u038d\u038b\3\2\2\2\u038e\u0391\3\2\2\2\u038f")
        buf.write("\u038d\3\2\2\2\u038f\u0390\3\2\2\2\u0390\u0394\3\2\2\2")
        buf.write("\u0391\u038f\3\2\2\2\u0392\u0393\7/\2\2\u0393\u0395\5")
        buf.write("\u00d8m\2\u0394\u0392\3\2\2\2\u0394\u0395\3\2\2\2\u0395")
        buf.write("\u0396\3\2\2\2\u0396\u0397\5V,\2\u0397\u0087\3\2\2\2\u0398")
        buf.write("\u0399\7\16\2\2\u0399\u039a\5\u0092J\2\u039a\u0089\3\2")
        buf.write("\2\2\u039b\u039c\5\2\2\2\u039c\u039d\7G\2\2\u039d\u039f")
        buf.write("\3\2\2\2\u039e\u039b\3\2\2\2\u039f\u03a2\3\2\2\2\u03a0")
        buf.write("\u039e\3\2\2\2\u03a0\u03a1\3\2\2\2\u03a1\u03a3\3\2\2\2")
        buf.write("\u03a2\u03a0\3\2\2\2\u03a3\u03a4\7\u0080\2\2\u03a4\u03a5")
        buf.write("\5\2\2\2\u03a5\u008b\3\2\2\2\u03a6\u03a7\7\u0080\2\2\u03a7")
        buf.write("\u03aa\5\u00dco\2\u03a8\u03aa\5\u008aF\2\u03a9\u03a6\3")
        buf.write("\2\2\2\u03a9\u03a8\3\2\2\2\u03aa\u03b1\3\2\2\2\u03ab\u03ae")
        buf.write("\7H\2\2\u03ac\u03af\5\u008eH\2\u03ad\u03af\5\u0092J\2")
        buf.write("\u03ae\u03ac\3\2\2\2\u03ae\u03ad\3\2\2\2\u03ae\u03af\3")
        buf.write("\2\2\2\u03af\u03b0\3\2\2\2\u03b0\u03b2\7I\2\2\u03b1\u03ab")
        buf.write("\3\2\2\2\u03b1\u03b2\3\2\2\2\u03b2\u008d\3\2\2\2\u03b3")
        buf.write("\u03b8\5\u0090I\2\u03b4\u03b5\7F\2\2\u03b5\u03b7\5\u0090")
        buf.write("I\2\u03b6\u03b4\3\2\2\2\u03b7\u03ba\3\2\2\2\u03b8\u03b6")
        buf.write("\3\2\2\2\u03b8\u03b9\3\2\2\2\u03b9\u008f\3\2\2\2\u03ba")
        buf.write("\u03b8\3\2\2\2\u03bb\u03bc\5\2\2\2\u03bc\u03bd\7\\\2\2")
        buf.write("\u03bd\u03be\5\u0092J\2\u03be\u0091\3\2\2\2\u03bf\u03c3")
        buf.write("\5\u00d2j\2\u03c0\u03c3\5\u008cG\2\u03c1\u03c3\5\u0094")
        buf.write("K\2\u03c2\u03bf\3\2\2\2\u03c2\u03c0\3\2\2\2\u03c2\u03c1")
        buf.write("\3\2\2\2\u03c3\u0093\3\2\2\2\u03c4\u03cd\7J\2\2\u03c5")
        buf.write("\u03ca\5\u0092J\2\u03c6\u03c7\7F\2\2\u03c7\u03c9\5\u0092")
        buf.write("J\2\u03c8\u03c6\3\2\2\2\u03c9\u03cc\3\2\2\2\u03ca\u03c8")
        buf.write("\3\2\2\2\u03ca\u03cb\3\2\2\2\u03cb\u03ce\3\2\2\2\u03cc")
        buf.write("\u03ca\3\2\2\2\u03cd\u03c5\3\2\2\2\u03cd\u03ce\3\2\2\2")
        buf.write("\u03ce\u03d0\3\2\2\2\u03cf\u03d1\7F\2\2\u03d0\u03cf\3")
        buf.write("\2\2\2\u03d0\u03d1\3\2\2\2\u03d1\u03d2\3\2\2\2\u03d2\u03d3")
        buf.write("\7K\2\2\u03d3\u0095\3\2\2\2\u03d4\u03d5\7\u0080\2\2\u03d5")
        buf.write("\u03d6\7\36\2\2\u03d6\u03d7\5\2\2\2\u03d7\u03d8\5\u0098")
        buf.write("M\2\u03d8\u0097\3\2\2\2\u03d9\u03dd\7J\2\2\u03da\u03dc")
        buf.write("\5\u009aN\2\u03db\u03da\3\2\2\2\u03dc\u03df\3\2\2\2\u03dd")
        buf.write("\u03db\3\2\2\2\u03dd\u03de\3\2\2\2\u03de\u03e0\3\2\2\2")
        buf.write("\u03df\u03dd\3\2\2\2\u03e0\u03e1\7K\2\2\u03e1\u0099\3")
        buf.write("\2\2\2\u03e2\u03e4\5\60\31\2\u03e3\u03e2\3\2\2\2\u03e4")
        buf.write("\u03e7\3\2\2\2\u03e5\u03e3\3\2\2\2\u03e5\u03e6\3\2\2\2")
        buf.write("\u03e6\u03e8\3\2\2\2\u03e7\u03e5\3\2\2\2\u03e8\u03eb\5")
        buf.write("\u009cO\2\u03e9\u03eb\7E\2\2\u03ea\u03e5\3\2\2\2\u03ea")
        buf.write("\u03e9\3\2\2\2\u03eb\u009b\3\2\2\2\u03ec\u03ed\5\f\7\2")
        buf.write("\u03ed\u03ee\5\u009eP\2\u03ee\u03ef\7E\2\2\u03ef\u0405")
        buf.write("\3\2\2\2\u03f0\u03f2\5\66\34\2\u03f1\u03f3\7E\2\2\u03f2")
        buf.write("\u03f1\3\2\2\2\u03f2\u03f3\3\2\2\2\u03f3\u0405\3\2\2\2")
        buf.write("\u03f4\u03f6\5p9\2\u03f5\u03f7\7E\2\2\u03f6\u03f5\3\2")
        buf.write("\2\2\u03f6\u03f7\3\2\2\2\u03f7\u0405\3\2\2\2\u03f8\u03fa")
        buf.write("\5\\/\2\u03f9\u03fb\7E\2\2\u03fa\u03f9\3\2\2\2\u03fa\u03fb")
        buf.write("\3\2\2\2\u03fb\u0405\3\2\2\2\u03fc\u03fe\5\u0096L\2\u03fd")
        buf.write("\u03ff\7E\2\2\u03fe\u03fd\3\2\2\2\u03fe\u03ff\3\2\2\2")
        buf.write("\u03ff\u0405\3\2\2\2\u0400\u0402\5d\63\2\u0401\u0403\7")
        buf.write("E\2\2\u0402\u0401\3\2\2\2\u0402\u0403\3\2\2\2\u0403\u0405")
        buf.write("\3\2\2\2\u0404\u03ec\3\2\2\2\u0404\u03f0\3\2\2\2\u0404")
        buf.write("\u03f4\3\2\2\2\u0404\u03f8\3\2\2\2\u0404\u03fc\3\2\2\2")
        buf.write("\u0404\u0400\3\2\2\2\u0405\u009d\3\2\2\2\u0406\u0409\5")
        buf.write("\u00a0Q\2\u0407\u0409\5\u00a2R\2\u0408\u0406\3\2\2\2\u0408")
        buf.write("\u0407\3\2\2\2\u0409\u009f\3\2\2\2\u040a\u040b\5\2\2\2")
        buf.write("\u040b\u040c\7H\2\2\u040c\u040e\7I\2\2\u040d\u040f\5\u0088")
        buf.write("E\2\u040e\u040d\3\2\2\2\u040e\u040f\3\2\2\2\u040f\u00a1")
        buf.write("\3\2\2\2\u0410\u0411\5B\"\2\u0411\u00a3\3\2\2\2\u0412")
        buf.write("\u041e\7J\2\2\u0413\u0418\5H%\2\u0414\u0415\7F\2\2\u0415")
        buf.write("\u0417\5H%\2\u0416\u0414\3\2\2\2\u0417\u041a\3\2\2\2\u0418")
        buf.write("\u0416\3\2\2\2\u0418\u0419\3\2\2\2\u0419\u041c\3\2\2\2")
        buf.write("\u041a\u0418\3\2\2\2\u041b\u041d\7F\2\2\u041c\u041b\3")
        buf.write("\2\2\2\u041c\u041d\3\2\2\2\u041d\u041f\3\2\2\2\u041e\u0413")
        buf.write("\3\2\2\2\u041e\u041f\3\2\2\2\u041f\u0420\3\2\2\2\u0420")
        buf.write("\u0421\7K\2\2\u0421\u00a5\3\2\2\2\u0422\u0426\7J\2\2\u0423")
        buf.write("\u0425\5\u00a8U\2\u0424\u0423\3\2\2\2\u0425\u0428\3\2")
        buf.write("\2\2\u0426\u0424\3\2\2\2\u0426\u0427\3\2\2\2\u0427\u0429")
        buf.write("\3\2\2\2\u0428\u0426\3\2\2\2\u0429\u042a\7K\2\2\u042a")
        buf.write("\u00a7\3\2\2\2\u042b\u042c\5\u00aaV\2\u042c\u042d\7E\2")
        buf.write("\2\u042d\u0431\3\2\2\2\u042e\u0431\5\u00dep\2\u042f\u0431")
        buf.write("\5\u00acW\2\u0430\u042b\3\2\2\2\u0430\u042e\3\2\2\2\u0430")
        buf.write("\u042f\3\2\2\2\u0431\u00a9\3\2\2\2\u0432\u0434\5T+\2\u0433")
        buf.write("\u0432\3\2\2\2\u0434\u0437\3\2\2\2\u0435\u0433\3\2\2\2")
        buf.write("\u0435\u0436\3\2\2\2\u0436\u0440\3\2\2\2\u0437\u0435\3")
        buf.write("\2\2\2\u0438\u0439\7?\2\2\u0439\u043a\5\2\2\2\u043a\u043b")
        buf.write("\7\\\2\2\u043b\u043c\5\u00d2j\2\u043c\u0441\3\2\2\2\u043d")
        buf.write("\u043e\5\f\7\2\u043e\u043f\5B\"\2\u043f\u0441\3\2\2\2")
        buf.write("\u0440\u0438\3\2\2\2\u0440\u043d\3\2\2\2\u0441\u00ab\3")
        buf.write("\2\2\2\u0442\u04b4\5\u00a6T\2\u0443\u0444\7\4\2\2\u0444")
        buf.write("\u0447\5\u00d2j\2\u0445\u0446\7b\2\2\u0446\u0448\5\u00d2")
        buf.write("j\2\u0447\u0445\3\2\2\2\u0447\u0448\3\2\2\2\u0448\u0449")
        buf.write("\3\2\2\2\u0449\u044a\7E\2\2\u044a\u04b4\3\2\2\2\u044b")
        buf.write("\u044c\7\30\2\2\u044c\u044d\5\u00e0q\2\u044d\u0450\5\u00ac")
        buf.write("W\2\u044e\u044f\7\21\2\2\u044f\u0451\5\u00acW\2\u0450")
        buf.write("\u044e\3\2\2\2\u0450\u0451\3\2\2\2\u0451\u04b4\3\2\2\2")
        buf.write("\u0452\u0453\7\27\2\2\u0453\u0454\7H\2\2\u0454\u0455\5")
        buf.write("\u00b6\\\2\u0455\u0456\7I\2\2\u0456\u0457\5\u00acW\2\u0457")
        buf.write("\u04b4\3\2\2\2\u0458\u0459\7\64\2\2\u0459\u045a\5\u00e0")
        buf.write("q\2\u045a\u045b\5\u00acW\2\u045b\u04b4\3\2\2\2\u045c\u045d")
        buf.write("\7\17\2\2\u045d\u045e\5\u00acW\2\u045e\u045f\7\64\2\2")
        buf.write("\u045f\u0460\5\u00e0q\2\u0460\u0461\7E\2\2\u0461\u04b4")
        buf.write("\3\2\2\2\u0462\u0463\7\61\2\2\u0463\u046d\5\u00a6T\2\u0464")
        buf.write("\u0466\5\u00ba^\2\u0465\u0464\3\2\2\2\u0466\u0467\3\2")
        buf.write("\2\2\u0467\u0465\3\2\2\2\u0467\u0468\3\2\2\2\u0468\u046a")
        buf.write("\3\2\2\2\u0469\u046b\5\u00be`\2\u046a\u0469\3\2\2\2\u046a")
        buf.write("\u046b\3\2\2\2\u046b\u046e\3\2\2\2\u046c\u046e\5\u00be")
        buf.write("`\2\u046d\u0465\3\2\2\2\u046d\u046c\3\2\2\2\u046e\u04b4")
        buf.write("\3\2\2\2\u046f\u0470\7\61\2\2\u0470\u0471\5\u00c0a\2\u0471")
        buf.write("\u0475\5\u00a6T\2\u0472\u0474\5\u00ba^\2\u0473\u0472\3")
        buf.write("\2\2\2\u0474\u0477\3\2\2\2\u0475\u0473\3\2\2\2\u0475\u0476")
        buf.write("\3\2\2\2\u0476\u0479\3\2\2\2\u0477\u0475\3\2\2\2\u0478")
        buf.write("\u047a\5\u00be`\2\u0479\u0478\3\2\2\2\u0479\u047a\3\2")
        buf.write("\2\2\u047a\u04b4\3\2\2\2\u047b\u047c\7+\2\2\u047c\u047d")
        buf.write("\5\u00e0q\2\u047d\u0481\7J\2\2\u047e\u0480\5\u00b0Y\2")
        buf.write("\u047f\u047e\3\2\2\2\u0480\u0483\3\2\2\2\u0481\u047f\3")
        buf.write("\2\2\2\u0481\u0482\3\2\2\2\u0482\u0487\3\2\2\2\u0483\u0481")
        buf.write("\3\2\2\2\u0484\u0486\5\u00b2Z\2\u0485\u0484\3\2\2\2\u0486")
        buf.write("\u0489\3\2\2\2\u0487\u0485\3\2\2\2\u0487\u0488\3\2\2\2")
        buf.write("\u0488\u048a\3\2\2\2\u0489\u0487\3\2\2\2\u048a\u048b\7")
        buf.write("K\2\2\u048b\u04b4\3\2\2\2\u048c\u048d\7,\2\2\u048d\u048e")
        buf.write("\5\u00e0q\2\u048e\u048f\5\u00a6T\2\u048f\u04b4\3\2\2\2")
        buf.write("\u0490\u0492\7&\2\2\u0491\u0493\5\u00d2j\2\u0492\u0491")
        buf.write("\3\2\2\2\u0492\u0493\3\2\2\2\u0493\u0494\3\2\2\2\u0494")
        buf.write("\u04b4\7E\2\2\u0495\u0496\7.\2\2\u0496\u0497\5\u00d2j")
        buf.write("\2\u0497\u0498\7E\2\2\u0498\u04b4\3\2\2\2\u0499\u049b")
        buf.write("\7\6\2\2\u049a\u049c\5\2\2\2\u049b\u049a\3\2\2\2\u049b")
        buf.write("\u049c\3\2\2\2\u049c\u049d\3\2\2\2\u049d\u04b4\7E\2\2")
        buf.write("\u049e\u04a0\7\r\2\2\u049f\u04a1\5\2\2\2\u04a0\u049f\3")
        buf.write("\2\2\2\u04a0\u04a1\3\2\2\2\u04a1\u04a2\3\2\2\2\u04a2\u04b4")
        buf.write("\7E\2\2\u04a3\u04a4\7@\2\2\u04a4\u04a5\5\u00d2j\2\u04a5")
        buf.write("\u04a6\7E\2\2\u04a6\u04b4\3\2\2\2\u04a7\u04b4\7E\2\2\u04a8")
        buf.write("\u04a9\5\u00d2j\2\u04a9\u04aa\7E\2\2\u04aa\u04b4\3\2\2")
        buf.write("\2\u04ab\u04ad\5\u00d4k\2\u04ac\u04ae\7E\2\2\u04ad\u04ac")
        buf.write("\3\2\2\2\u04ad\u04ae\3\2\2\2\u04ae\u04b4\3\2\2\2\u04af")
        buf.write("\u04b0\5\2\2\2\u04b0\u04b1\7b\2\2\u04b1\u04b2\5\u00ac")
        buf.write("W\2\u04b2\u04b4\3\2\2\2\u04b3\u0442\3\2\2\2\u04b3\u0443")
        buf.write("\3\2\2\2\u04b3\u044b\3\2\2\2\u04b3\u0452\3\2\2\2\u04b3")
        buf.write("\u0458\3\2\2\2\u04b3\u045c\3\2\2\2\u04b3\u0462\3\2\2\2")
        buf.write("\u04b3\u046f\3\2\2\2\u04b3\u047b\3\2\2\2\u04b3\u048c\3")
        buf.write("\2\2\2\u04b3\u0490\3\2\2\2\u04b3\u0495\3\2\2\2\u04b3\u0499")
        buf.write("\3\2\2\2\u04b3\u049e\3\2\2\2\u04b3\u04a3\3\2\2\2\u04b3")
        buf.write("\u04a7\3\2\2\2\u04b3\u04a8\3\2\2\2\u04b3\u04ab\3\2\2\2")
        buf.write("\u04b3\u04af\3\2\2\2\u04b4\u00ad\3\2\2\2\u04b5\u04bd\5")
        buf.write("\u00a6T\2\u04b6\u04b8\5\u00a8U\2\u04b7\u04b6\3\2\2\2\u04b8")
        buf.write("\u04bb\3\2\2\2\u04b9\u04b7\3\2\2\2\u04b9\u04ba\3\2\2\2")
        buf.write("\u04ba\u04bd\3\2\2\2\u04bb\u04b9\3\2\2\2\u04bc\u04b5\3")
        buf.write("\2\2\2\u04bc\u04b9\3\2\2\2\u04bd\u00af\3\2\2\2\u04be\u04c0")
        buf.write("\5\u00b2Z\2\u04bf\u04be\3\2\2\2\u04c0\u04c1\3\2\2\2\u04c1")
        buf.write("\u04bf\3\2\2\2\u04c1\u04c2\3\2\2\2\u04c2\u04c4\3\2\2\2")
        buf.write("\u04c3\u04c5\5\u00a8U\2\u04c4\u04c3\3\2\2\2\u04c5\u04c6")
        buf.write("\3\2\2\2\u04c6\u04c4\3\2\2\2\u04c6\u04c7\3\2\2\2\u04c7")
        buf.write("\u00b1\3\2\2\2\u04c8\u04ce\7\b\2\2\u04c9\u04cf\5\u00d2")
        buf.write("j\2\u04ca\u04cf\7\u0082\2\2\u04cb\u04cc\5\f\7\2\u04cc")
        buf.write("\u04cd\5\2\2\2\u04cd\u04cf\3\2\2\2\u04ce\u04c9\3\2\2\2")
        buf.write("\u04ce\u04ca\3\2\2\2\u04ce\u04cb\3\2\2\2\u04cf\u04d0\3")
        buf.write("\2\2\2\u04d0\u04d4\7b\2\2\u04d1\u04d2\7\16\2\2\u04d2\u04d4")
        buf.write("\7b\2\2\u04d3\u04c8\3\2\2\2\u04d3\u04d1\3\2\2\2\u04d4")
        buf.write("\u00b3\3\2\2\2\u04d5\u04d8\5\u00aaV\2\u04d6\u04d8\5\u00e2")
        buf.write("r\2\u04d7\u04d5\3\2\2\2\u04d7\u04d6\3\2\2\2\u04d8\u00b5")
        buf.write("\3\2\2\2\u04d9\u04e6\5\u00b8]\2\u04da\u04dc\5\u00b4[\2")
        buf.write("\u04db\u04da\3\2\2\2\u04db\u04dc\3\2\2\2\u04dc\u04dd\3")
        buf.write("\2\2\2\u04dd\u04df\7E\2\2\u04de\u04e0\5\u00d2j\2\u04df")
        buf.write("\u04de\3\2\2\2\u04df\u04e0\3\2\2\2\u04e0\u04e1\3\2\2\2")
        buf.write("\u04e1\u04e3\7E\2\2\u04e2\u04e4\5\u00e2r\2\u04e3\u04e2")
        buf.write("\3\2\2\2\u04e3\u04e4\3\2\2\2\u04e4\u04e6\3\2\2\2\u04e5")
        buf.write("\u04d9\3\2\2\2\u04e5\u04db\3\2\2\2\u04e6\u00b7\3\2\2\2")
        buf.write("\u04e7\u04e9\5T+\2\u04e8\u04e7\3\2\2\2\u04e9\u04ec\3\2")
        buf.write("\2\2\u04ea\u04e8\3\2\2\2\u04ea\u04eb\3\2\2\2\u04eb\u04ef")
        buf.write("\3\2\2\2\u04ec\u04ea\3\2\2\2\u04ed\u04f0\5\f\7\2\u04ee")
        buf.write("\u04f0\7?\2\2\u04ef\u04ed\3\2\2\2\u04ef\u04ee\3\2\2\2")
        buf.write("\u04f0\u04f1\3\2\2\2\u04f1\u04f2\5F$\2\u04f2\u04f3\7b")
        buf.write("\2\2\u04f3\u04f4\5\u00d2j\2\u04f4\u00b9\3\2\2\2\u04f5")
        buf.write("\u04f6\7\t\2\2\u04f6\u04fa\7H\2\2\u04f7\u04f9\5T+\2\u04f8")
        buf.write("\u04f7\3\2\2\2\u04f9\u04fc\3\2\2\2\u04fa\u04f8\3\2\2\2")
        buf.write("\u04fa\u04fb\3\2\2\2\u04fb\u04fd\3\2\2\2\u04fc\u04fa\3")
        buf.write("\2\2\2\u04fd\u04fe\5\u00bc_\2\u04fe\u04ff\5\2\2\2\u04ff")
        buf.write("\u0500\7I\2\2\u0500\u0501\5\u00a6T\2\u0501\u00bb\3\2\2")
        buf.write("\2\u0502\u0507\5\u00dco\2\u0503\u0504\7p\2\2\u0504\u0506")
        buf.write("\5\u00dco\2\u0505\u0503\3\2\2\2\u0506\u0509\3\2\2\2\u0507")
        buf.write("\u0505\3\2\2\2\u0507\u0508\3\2\2\2\u0508\u00bd\3\2\2\2")
        buf.write("\u0509\u0507\3\2\2\2\u050a\u050b\7\25\2\2\u050b\u050c")
        buf.write("\5\u00a6T\2\u050c\u00bf\3\2\2\2\u050d\u050e\7H\2\2\u050e")
        buf.write("\u0510\5\u00c2b\2\u050f\u0511\7E\2\2\u0510\u050f\3\2\2")
        buf.write("\2\u0510\u0511\3\2\2\2\u0511\u0512\3\2\2\2\u0512\u0513")
        buf.write("\7I\2\2\u0513\u00c1\3\2\2\2\u0514\u0519\5\u00c4c\2\u0515")
        buf.write("\u0516\7E\2\2\u0516\u0518\5\u00c4c\2\u0517\u0515\3\2\2")
        buf.write("\2\u0518\u051b\3\2\2\2\u0519\u0517\3\2\2\2\u0519\u051a")
        buf.write("\3\2\2\2\u051a\u00c3\3\2\2\2\u051b\u0519\3\2\2\2\u051c")
        buf.write("\u051e\5T+\2\u051d\u051c\3\2\2\2\u051e\u0521\3\2\2\2\u051f")
        buf.write("\u051d\3\2\2\2\u051f\u0520\3\2\2\2\u0520\u0527\3\2\2\2")
        buf.write("\u0521\u051f\3\2\2\2\u0522\u0523\5\36\20\2\u0523\u0524")
        buf.write("\5F$\2\u0524\u0528\3\2\2\2\u0525\u0526\7?\2\2\u0526\u0528")
        buf.write("\5\2\2\2\u0527\u0522\3\2\2\2\u0527\u0525\3\2\2\2\u0528")
        buf.write("\u0529\3\2\2\2\u0529\u052a\7\\\2\2\u052a\u052b\5\u00d2")
        buf.write("j\2\u052b\u052e\3\2\2\2\u052c\u052e\5\2\2\2\u052d\u051f")
        buf.write("\3\2\2\2\u052d\u052c\3\2\2\2\u052e\u00c5\3\2\2\2\u052f")
        buf.write("\u0531\5T+\2\u0530\u052f\3\2\2\2\u0531\u0534\3\2\2\2\u0532")
        buf.write("\u0530\3\2\2\2\u0532\u0533\3\2\2\2\u0533\u0535\3\2\2\2")
        buf.write("\u0534\u0532\3\2\2\2\u0535\u0539\5\f\7\2\u0536\u0538\5")
        buf.write("\u008cG\2\u0537\u0536\3\2\2\2\u0538\u053b\3\2\2\2\u0539")
        buf.write("\u0537\3\2\2\2\u0539\u053a\3\2\2\2\u053a\u053c\3\2\2\2")
        buf.write("\u053b\u0539\3\2\2\2\u053c\u053d\5\2\2\2\u053d\u00c7\3")
        buf.write("\2\2\2\u053e\u053f\7H\2\2\u053f\u0540\5\u00d2j\2\u0540")
        buf.write("\u0541\7I\2\2\u0541\u0551\3\2\2\2\u0542\u0551\7-\2\2\u0543")
        buf.write("\u0551\7*\2\2\u0544\u0551\5\u00caf\2\u0545\u0551\5\2\2")
        buf.write("\2\u0546\u0547\5t;\2\u0547\u0548\7G\2\2\u0548\u0549\7")
        buf.write("\13\2\2\u0549\u0551\3\2\2\2\u054a\u054e\5\b\5\2\u054b")
        buf.write("\u054f\5\32\16\2\u054c\u054d\7-\2\2\u054d\u054f\5\34\17")
        buf.write("\2\u054e\u054b\3\2\2\2\u054e\u054c\3\2\2\2\u054f\u0551")
        buf.write("\3\2\2\2\u0550\u053e\3\2\2\2\u0550\u0542\3\2\2\2\u0550")
        buf.write("\u0543\3\2\2\2\u0550\u0544\3\2\2\2\u0550\u0545\3\2\2\2")
        buf.write("\u0550\u0546\3\2\2\2\u0550\u054a\3\2\2\2\u0551\u00c9\3")
        buf.write("\2\2\2\u0552\u055a\5\u00ccg\2\u0553\u055a\5\u00ceh\2\u0554")
        buf.write("\u055a\7U\2\2\u0555\u055a\7V\2\2\u0556\u055a\7T\2\2\u0557")
        buf.write("\u055a\7X\2\2\u0558\u055a\7W\2\2\u0559\u0552\3\2\2\2\u0559")
        buf.write("\u0553\3\2\2\2\u0559\u0554\3\2\2\2\u0559\u0555\3\2\2\2")
        buf.write("\u0559\u0556\3\2\2\2\u0559\u0557\3\2\2\2\u0559\u0558\3")
        buf.write("\2\2\2\u055a\u00cb\3\2\2\2\u055b\u055c\t\7\2\2\u055c\u00cd")
        buf.write("\3\2\2\2\u055d\u055e\t\b\2\2\u055e\u00cf\3\2\2\2\u055f")
        buf.write("\u0560\7^\2\2\u0560\u0563\7]\2\2\u0561\u0563\5\26\f\2")
        buf.write("\u0562\u055f\3\2\2\2\u0562\u0561\3\2\2\2\u0563\u00d1\3")
        buf.write("\2\2\2\u0564\u0565\bj\1\2\u0565\u0591\5\u00c8e\2\u0566")
        buf.write("\u0591\5\u00e4s\2\u0567\u0568\7!\2\2\u0568\u0591\5\u00e8")
        buf.write("u\2\u0569\u056d\7H\2\2\u056a\u056c\5\u008cG\2\u056b\u056a")
        buf.write("\3\2\2\2\u056c\u056f\3\2\2\2\u056d\u056b\3\2\2\2\u056d")
        buf.write("\u056e\3\2\2\2\u056e\u0570\3\2\2\2\u056f\u056d\3\2\2\2")
        buf.write("\u0570\u0575\5\f\7\2\u0571\u0572\7o\2\2\u0572\u0574\5")
        buf.write("\f\7\2\u0573\u0571\3\2\2\2\u0574\u0577\3\2\2\2\u0575\u0573")
        buf.write("\3\2\2\2\u0575\u0576\3\2\2\2\u0576\u0578\3\2\2\2\u0577")
        buf.write("\u0575\3\2\2\2\u0578\u0579\7I\2\2\u0579\u057a\5\u00d2")
        buf.write("j\27\u057a\u0591\3\2\2\2\u057b\u057c\t\t\2\2\u057c\u0591")
        buf.write("\5\u00d2j\25\u057d\u057e\t\n\2\2\u057e\u0591\5\u00d2j")
        buf.write("\24\u057f\u0591\5\u00d4k\2\u0580\u0581\5\f\7\2\u0581\u0587")
        buf.write("\7\177\2\2\u0582\u0584\5\26\f\2\u0583\u0582\3\2\2\2\u0583")
        buf.write("\u0584\3\2\2\2\u0584\u0585\3\2\2\2\u0585\u0588\5\2\2\2")
        buf.write("\u0586\u0588\7!\2\2\u0587\u0583\3\2\2\2\u0587\u0586\3")
        buf.write("\2\2\2\u0588\u0591\3\2\2\2\u0589\u058a\5 \21\2\u058a\u058c")
        buf.write("\7\177\2\2\u058b\u058d\5\26\f\2\u058c\u058b\3\2\2\2\u058c")
        buf.write("\u058d\3\2\2\2\u058d\u058e\3\2\2\2\u058e\u058f\7!\2\2")
        buf.write("\u058f\u0591\3\2\2\2\u0590\u0564\3\2\2\2\u0590\u0566\3")
        buf.write("\2\2\2\u0590\u0567\3\2\2\2\u0590\u0569\3\2\2\2\u0590\u057b")
        buf.write("\3\2\2\2\u0590\u057d\3\2\2\2\u0590\u057f\3\2\2\2\u0590")
        buf.write("\u0580\3\2\2\2\u0590\u0589\3\2\2\2\u0591\u05e5\3\2\2\2")
        buf.write("\u0592\u0593\f\23\2\2\u0593\u0594\t\13\2\2\u0594\u05e4")
        buf.write("\5\u00d2j\24\u0595\u0596\f\22\2\2\u0596\u0597\t\f\2\2")
        buf.write("\u0597\u05e4\5\u00d2j\23\u0598\u05a0\f\21\2\2\u0599\u059a")
        buf.write("\7^\2\2\u059a\u05a1\7^\2\2\u059b\u059c\7]\2\2\u059c\u059d")
        buf.write("\7]\2\2\u059d\u05a1\7]\2\2\u059e\u059f\7]\2\2\u059f\u05a1")
        buf.write("\7]\2\2\u05a0\u0599\3\2\2\2\u05a0\u059b\3\2\2\2\u05a0")
        buf.write("\u059e\3\2\2\2\u05a1\u05a2\3\2\2\2\u05a2\u05e4\5\u00d2")
        buf.write("j\22\u05a3\u05a4\f\20\2\2\u05a4\u05a5\t\r\2\2\u05a5\u05e4")
        buf.write("\5\u00d2j\21\u05a6\u05a7\f\16\2\2\u05a7\u05a8\t\16\2\2")
        buf.write("\u05a8\u05e4\5\u00d2j\17\u05a9\u05aa\f\r\2\2\u05aa\u05ab")
        buf.write("\7o\2\2\u05ab\u05e4\5\u00d2j\16\u05ac\u05ad\f\f\2\2\u05ad")
        buf.write("\u05ae\7q\2\2\u05ae\u05e4\5\u00d2j\r\u05af\u05b0\f\13")
        buf.write("\2\2\u05b0\u05b1\7p\2\2\u05b1\u05e4\5\u00d2j\f\u05b2\u05b3")
        buf.write("\f\n\2\2\u05b3\u05b4\7g\2\2\u05b4\u05e4\5\u00d2j\13\u05b5")
        buf.write("\u05b6\f\t\2\2\u05b6\u05b7\7h\2\2\u05b7\u05e4\5\u00d2")
        buf.write("j\n\u05b8\u05b9\f\b\2\2\u05b9\u05ba\7a\2\2\u05ba\u05bb")
        buf.write("\5\u00d2j\2\u05bb\u05bc\7b\2\2\u05bc\u05bd\5\u00d2j\b")
        buf.write("\u05bd\u05e4\3\2\2\2\u05be\u05bf\f\7\2\2\u05bf\u05c0\t")
        buf.write("\17\2\2\u05c0\u05e4\5\u00d2j\7\u05c1\u05c2\f\33\2\2\u05c2")
        buf.write("\u05ce\7G\2\2\u05c3\u05cf\5\2\2\2\u05c4\u05cf\5\u00e4")
        buf.write("s\2\u05c5\u05cf\7-\2\2\u05c6\u05c8\7!\2\2\u05c7\u05c9")
        buf.write("\5\b\5\2\u05c8\u05c7\3\2\2\2\u05c8\u05c9\3\2\2\2\u05c9")
        buf.write("\u05ca\3\2\2\2\u05ca\u05cf\5\u00ecw\2\u05cb\u05cc\7*\2")
        buf.write("\2\u05cc\u05cf\5\30\r\2\u05cd\u05cf\5\u00f2z\2\u05ce\u05c3")
        buf.write("\3\2\2\2\u05ce\u05c4\3\2\2\2\u05ce\u05c5\3\2\2\2\u05ce")
        buf.write("\u05c6\3\2\2\2\u05ce\u05cb\3\2\2\2\u05ce\u05cd\3\2\2\2")
        buf.write("\u05cf\u05e4\3\2\2\2\u05d0\u05d1\f\32\2\2\u05d1\u05d2")
        buf.write("\7L\2\2\u05d2\u05d3\5\u00d2j\2\u05d3\u05d4\7M\2\2\u05d4")
        buf.write("\u05e4\3\2\2\2\u05d5\u05d6\f\26\2\2\u05d6\u05e4\t\20\2")
        buf.write("\2\u05d7\u05d8\f\17\2\2\u05d8\u05db\7\34\2\2\u05d9\u05dc")
        buf.write("\5\f\7\2\u05da\u05dc\5\u00c6d\2\u05db\u05d9\3\2\2\2\u05db")
        buf.write("\u05da\3\2\2\2\u05dc\u05e4\3\2\2\2\u05dd\u05de\f\5\2\2")
        buf.write("\u05de\u05e0\7\177\2\2\u05df\u05e1\5\26\f\2\u05e0\u05df")
        buf.write("\3\2\2\2\u05e0\u05e1\3\2\2\2\u05e1\u05e2\3\2\2\2\u05e2")
        buf.write("\u05e4\5\2\2\2\u05e3\u0592\3\2\2\2\u05e3\u0595\3\2\2\2")
        buf.write("\u05e3\u0598\3\2\2\2\u05e3\u05a3\3\2\2\2\u05e3\u05a6\3")
        buf.write("\2\2\2\u05e3\u05a9\3\2\2\2\u05e3\u05ac\3\2\2\2\u05e3\u05af")
        buf.write("\3\2\2\2\u05e3\u05b2\3\2\2\2\u05e3\u05b5\3\2\2\2\u05e3")
        buf.write("\u05b8\3\2\2\2\u05e3\u05be\3\2\2\2\u05e3\u05c1\3\2\2\2")
        buf.write("\u05e3\u05d0\3\2\2\2\u05e3\u05d5\3\2\2\2\u05e3\u05d7\3")
        buf.write("\2\2\2\u05e3\u05dd\3\2\2\2\u05e4\u05e7\3\2\2\2\u05e5\u05e3")
        buf.write("\3\2\2\2\u05e5\u05e6\3\2\2\2\u05e6\u00d3\3\2\2\2\u05e7")
        buf.write("\u05e5\3\2\2\2\u05e8\u05e9\7+\2\2\u05e9\u05ea\5\u00e0")
        buf.write("q\2\u05ea\u05ee\7J\2\2\u05eb\u05ed\5\u00d6l\2\u05ec\u05eb")
        buf.write("\3\2\2\2\u05ed\u05f0\3\2\2\2\u05ee\u05ec\3\2\2\2\u05ee")
        buf.write("\u05ef\3\2\2\2\u05ef\u05f1\3\2\2\2\u05f0\u05ee\3\2\2\2")
        buf.write("\u05f1\u05f2\7K\2\2\u05f2\u00d5\3\2\2\2\u05f3\u05f7\7")
        buf.write("\b\2\2\u05f4\u05f8\5\u00e2r\2\u05f5\u05f8\7X\2\2\u05f6")
        buf.write("\u05f8\5\u00e6t\2\u05f7\u05f4\3\2\2\2\u05f7\u05f5\3\2")
        buf.write("\2\2\u05f7\u05f6\3\2\2\2\u05f8\u05f9\3\2\2\2\u05f9\u05fa")
        buf.write("\t\21\2\2\u05fa\u05ff\5\u00aeX\2\u05fb\u05fc\7\16\2\2")
        buf.write("\u05fc\u05fd\t\21\2\2\u05fd\u05ff\5\u00aeX\2\u05fe\u05f3")
        buf.write("\3\2\2\2\u05fe\u05fb\3\2\2\2\u05ff\u00d7\3\2\2\2\u0600")
        buf.write("\u0605\5\u00dco\2\u0601\u0602\7F\2\2\u0602\u0604\5\u00dc")
        buf.write("o\2\u0603\u0601\3\2\2\2\u0604\u0607\3\2\2\2\u0605\u0603")
        buf.write("\3\2\2\2\u0605\u0606\3\2\2\2\u0606\u00d9\3\2\2\2\u0607")
        buf.write("\u0605\3\2\2\2\u0608\u060a\5T+\2\u0609\u0608\3\2\2\2\u060a")
        buf.write("\u060d\3\2\2\2\u060b\u0609\3\2\2\2\u060b\u060c\3\2\2\2")
        buf.write("\u060c\u060e\3\2\2\2\u060d\u060b\3\2\2\2\u060e\u0612\5")
        buf.write("\f\7\2\u060f\u0611\5\u008cG\2\u0610\u060f\3\2\2\2\u0611")
        buf.write("\u0614\3\2\2\2\u0612\u0610\3\2\2\2\u0612\u0613\3\2\2\2")
        buf.write("\u0613\u0615\3\2\2\2\u0614\u0612\3\2\2\2\u0615\u0616\7")
        buf.write("\u0081\2\2\u0616\u0617\5F$\2\u0617\u00db\3\2\2\2\u0618")
        buf.write("\u061d\5\2\2\2\u0619\u061a\7G\2\2\u061a\u061c\5\2\2\2")
        buf.write("\u061b\u0619\3\2\2\2\u061c\u061f\3\2\2\2\u061d\u061b\3")
        buf.write("\2\2\2\u061d\u061e\3\2\2\2\u061e\u00dd\3\2\2\2\u061f\u061d")
        buf.write("\3\2\2\2\u0620\u0622\5\64\33\2\u0621\u0620\3\2\2\2\u0622")
        buf.write("\u0625\3\2\2\2\u0623\u0621\3\2\2\2\u0623\u0624\3\2\2\2")
        buf.write("\u0624\u0629\3\2\2\2\u0625\u0623\3\2\2\2\u0626\u062a\5")
        buf.write("\66\34\2\u0627\u062a\5p9\2\u0628\u062a\5d\63\2\u0629\u0626")
        buf.write("\3\2\2\2\u0629\u0627\3\2\2\2\u0629\u0628\3\2\2\2\u062a")
        buf.write("\u00df\3\2\2\2\u062b\u062c\7H\2\2\u062c\u062d\5\u00d2")
        buf.write("j\2\u062d\u062e\7I\2\2\u062e\u00e1\3\2\2\2\u062f\u0634")
        buf.write("\5\u00d2j\2\u0630\u0631\7F\2\2\u0631\u0633\5\u00d2j\2")
        buf.write("\u0632\u0630\3\2\2\2\u0633\u0636\3\2\2\2\u0634\u0632\3")
        buf.write("\2\2\2\u0634\u0635\3\2\2\2\u0635\u00e3\3\2\2\2\u0636\u0634")
        buf.write("\3\2\2\2\u0637\u0638\5\2\2\2\u0638\u063a\7H\2\2\u0639")
        buf.write("\u063b\5\u00e2r\2\u063a\u0639\3\2\2\2\u063a\u063b\3\2")
        buf.write("\2\2\u063b\u063c\3\2\2\2\u063c\u063d\7I\2\2\u063d\u064b")
        buf.write("\3\2\2\2\u063e\u063f\7-\2\2\u063f\u0641\7H\2\2\u0640\u0642")
        buf.write("\5\u00e2r\2\u0641\u0640\3\2\2\2\u0641\u0642\3\2\2\2\u0642")
        buf.write("\u0643\3\2\2\2\u0643\u064b\7I\2\2\u0644\u0645\7*\2\2\u0645")
        buf.write("\u0647\7H\2\2\u0646\u0648\5\u00e2r\2\u0647\u0646\3\2\2")
        buf.write("\2\u0647\u0648\3\2\2\2\u0648\u0649\3\2\2\2\u0649\u064b")
        buf.write("\7I\2\2\u064a\u0637\3\2\2\2\u064a\u063e\3\2\2\2\u064a")
        buf.write("\u0644\3\2\2\2\u064b\u00e5\3\2\2\2\u064c\u064d\bt\1\2")
        buf.write("\u064d\u064e\7H\2\2\u064e\u064f\5\u00e6t\2\u064f\u0650")
        buf.write("\7I\2\2\u0650\u0667\3\2\2\2\u0651\u0653\5T+\2\u0652\u0651")
        buf.write("\3\2\2\2\u0653\u0656\3\2\2\2\u0654\u0652\3\2\2\2\u0654")
        buf.write("\u0655\3\2\2\2\u0655\u0657\3\2\2\2\u0656\u0654\3\2\2\2")
        buf.write("\u0657\u065b\5\f\7\2\u0658\u065a\5\u008cG\2\u0659\u0658")
        buf.write("\3\2\2\2\u065a\u065d\3\2\2\2\u065b\u0659\3\2\2\2\u065b")
        buf.write("\u065c\3\2\2\2\u065c\u065e\3\2\2\2\u065d\u065b\3\2\2\2")
        buf.write("\u065e\u0663\5\2\2\2\u065f\u0660\7g\2\2\u0660\u0662\5")
        buf.write("\u00d2j\2\u0661\u065f\3\2\2\2\u0662\u0665\3\2\2\2\u0663")
        buf.write("\u0661\3\2\2\2\u0663\u0664\3\2\2\2\u0664\u0667\3\2\2\2")
        buf.write("\u0665\u0663\3\2\2\2\u0666\u064c\3\2\2\2\u0666\u0654\3")
        buf.write("\2\2\2\u0667\u066d\3\2\2\2\u0668\u0669\f\3\2\2\u0669\u066a")
        buf.write("\7g\2\2\u066a\u066c\5\u00d2j\2\u066b\u0668\3\2\2\2\u066c")
        buf.write("\u066f\3\2\2\2\u066d\u066b\3\2\2\2\u066d\u066e\3\2\2\2")
        buf.write("\u066e\u00e7\3\2\2\2\u066f\u066d\3\2\2\2\u0670\u0671\5")
        buf.write("\b\5\2\u0671\u0672\5\u00eav\2\u0672\u0673\5\u00f0y\2\u0673")
        buf.write("\u067a\3\2\2\2\u0674\u0677\5\u00eav\2\u0675\u0678\5\u00ee")
        buf.write("x\2\u0676\u0678\5\u00f0y\2\u0677\u0675\3\2\2\2\u0677\u0676")
        buf.write("\3\2\2\2\u0678\u067a\3\2\2\2\u0679\u0670\3\2\2\2\u0679")
        buf.write("\u0674\3\2\2\2\u067a\u00e9\3\2\2\2\u067b\u067d\5\2\2\2")
        buf.write("\u067c\u067e\5\u00d0i\2\u067d\u067c\3\2\2\2\u067d\u067e")
        buf.write("\3\2\2\2\u067e\u0686\3\2\2\2\u067f\u0680\7G\2\2\u0680")
        buf.write("\u0682\5\2\2\2\u0681\u0683\5\u00d0i\2\u0682\u0681\3\2")
        buf.write("\2\2\u0682\u0683\3\2\2\2\u0683\u0685\3\2\2\2\u0684\u067f")
        buf.write("\3\2\2\2\u0685\u0688\3\2\2\2\u0686\u0684\3\2\2\2\u0686")
        buf.write("\u0687\3\2\2\2\u0687\u068b\3\2\2\2\u0688\u0686\3\2\2\2")
        buf.write("\u0689\u068b\5\16\b\2\u068a\u067b\3\2\2\2\u068a\u0689")
        buf.write("\3\2\2\2\u068b\u00eb\3\2\2\2\u068c\u068e\5\2\2\2\u068d")
        buf.write("\u068f\5\6\4\2\u068e\u068d\3\2\2\2\u068e\u068f\3\2\2\2")
        buf.write("\u068f\u0690\3\2\2\2\u0690\u0691\5\u00f0y\2\u0691\u00ed")
        buf.write("\3\2\2\2\u0692\u06ae\7L\2\2\u0693\u0698\7M\2\2\u0694\u0695")
        buf.write("\7L\2\2\u0695\u0697\7M\2\2\u0696\u0694\3\2\2\2\u0697\u069a")
        buf.write("\3\2\2\2\u0698\u0696\3\2\2\2\u0698\u0699\3\2\2\2\u0699")
        buf.write("\u069b\3\2\2\2\u069a\u0698\3\2\2\2\u069b\u06af\5\u00a4")
        buf.write("S\2\u069c\u069d\5\u00d2j\2\u069d\u06a4\7M\2\2\u069e\u069f")
        buf.write("\7L\2\2\u069f\u06a0\5\u00d2j\2\u06a0\u06a1\7M\2\2\u06a1")
        buf.write("\u06a3\3\2\2\2\u06a2\u069e\3\2\2\2\u06a3\u06a6\3\2\2\2")
        buf.write("\u06a4\u06a2\3\2\2\2\u06a4\u06a5\3\2\2\2\u06a5\u06ab\3")
        buf.write("\2\2\2\u06a6\u06a4\3\2\2\2\u06a7\u06a8\7L\2\2\u06a8\u06aa")
        buf.write("\7M\2\2\u06a9\u06a7\3\2\2\2\u06aa\u06ad\3\2\2\2\u06ab")
        buf.write("\u06a9\3\2\2\2\u06ab\u06ac\3\2\2\2\u06ac\u06af\3\2\2\2")
        buf.write("\u06ad\u06ab\3\2\2\2\u06ae\u0693\3\2\2\2\u06ae\u069c\3")
        buf.write("\2\2\2\u06af\u00ef\3\2\2\2\u06b0\u06b2\5\34\17\2\u06b1")
        buf.write("\u06b3\5:\36\2\u06b2\u06b1\3\2\2\2\u06b2\u06b3\3\2\2\2")
        buf.write("\u06b3\u00f1\3\2\2\2\u06b4\u06b5\5\b\5\2\u06b5\u06b6\5")
        buf.write("\32\16\2\u06b6\u00f3\3\2\2\2\u00d8\u00fb\u0106\u010c\u0111")
        buf.write("\u0116\u011d\u0125\u012d\u0131\u0138\u013f\u0145\u0147")
        buf.write("\u014f\u0157\u015b\u015d\u0164\u0168\u016e\u0174\u0179")
        buf.write("\u017e\u0183\u0188\u018b\u0190\u0196\u019c\u01a1\u01aa")
        buf.write("\u01af\u01b4\u01bd\u01c5\u01c8\u01ce\u01d7\u01e1\u01e9")
        buf.write("\u01f7\u01fe\u020c\u0211\u0215\u0219\u021d\u0227\u0230")
        buf.write("\u0237\u023d\u0241\u024d\u0258\u025e\u0265\u026a\u0273")
        buf.write("\u0278\u0282\u028c\u0291\u0294\u0298\u029d\u02a0\u02a2")
        buf.write("\u02a9\u02b1\u02b5\u02be\u02c6\u02ca\u02cd\u02d0\u02d9")
        buf.write("\u02df\u02e4\u02e7\u02ed\u02f3\u02f8\u02fe\u0307\u0310")
        buf.write("\u0312\u031a\u0323\u0327\u032b\u0333\u033a\u0342\u0347")
        buf.write("\u0351\u0359\u0363\u036c\u0377\u037c\u0385\u038f\u0394")
        buf.write("\u03a0\u03a9\u03ae\u03b1\u03b8\u03c2\u03ca\u03cd\u03d0")
        buf.write("\u03dd\u03e5\u03ea\u03f2\u03f6\u03fa\u03fe\u0402\u0404")
        buf.write("\u0408\u040e\u0418\u041c\u041e\u0426\u0430\u0435\u0440")
        buf.write("\u0447\u0450\u0467\u046a\u046d\u0475\u0479\u0481\u0487")
        buf.write("\u0492\u049b\u04a0\u04ad\u04b3\u04b9\u04bc\u04c1\u04c6")
        buf.write("\u04ce\u04d3\u04d7\u04db\u04df\u04e3\u04e5\u04ea\u04ef")
        buf.write("\u04fa\u0507\u0510\u0519\u051f\u0527\u052d\u0532\u0539")
        buf.write("\u054e\u0550\u0559\u0562\u056d\u0575\u0583\u0587\u058c")
        buf.write("\u0590\u05a0\u05c8\u05ce\u05db\u05e0\u05e3\u05e5\u05ee")
        buf.write("\u05f7\u05fe\u0605\u060b\u0612\u061d\u0623\u0629\u0634")
        buf.write("\u063a\u0641\u0647\u064a\u0654\u065b\u0663\u0666\u066d")
        buf.write("\u0677\u0679\u067d\u0682\u0686\u068a\u068e\u0698\u06a4")
        buf.write("\u06ab\u06ae\u06b2")
        return buf.getvalue()


class JavaParser ( Parser ):

    grammarFileName = "JavaParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'abstract'", "'assert'", "'boolean'", 
                     "'break'", "'byte'", "'case'", "'catch'", "'char'", 
                     "'class'", "'const'", "'continue'", "'default'", "'do'", 
                     "'double'", "'else'", "'enum'", "'extends'", "'final'", 
                     "'finally'", "'float'", "'for'", "'if'", "'goto'", 
                     "'implements'", "'import'", "'instanceof'", "'int'", 
                     "'interface'", "'long'", "'native'", "'new'", "'package'", 
                     "'private'", "'protected'", "'public'", "'return'", 
                     "'short'", "'static'", "'strictfp'", "'super'", "'switch'", 
                     "'synchronized'", "'this'", "'throw'", "'throws'", 
                     "'transient'", "'try'", "'void'", "'volatile'", "'while'", 
                     "'module'", "'open'", "'requires'", "'exports'", "'opens'", 
                     "'to'", "'uses'", "'provides'", "'with'", "'transitive'", 
                     "'var'", "'yield'", "'record'", "'sealed'", "'permits'", 
                     "'non-sealed'", "';'", "','", "'.'", "'('", "')'", 
                     "'{'", "'}'", "'['", "']'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'null'", "<INVALID>", "<INVALID>", "<INVALID>", "'='", 
                     "'>'", "'<'", "'!'", "'~'", "'?'", "':'", "'=='", "'<='", 
                     "'>='", "'!='", "'&&'", "'||'", "'++'", "'--'", "'+'", 
                     "'-'", "'*'", "'/'", "'&'", "'|'", "'^'", "'%'", "'+='", 
                     "'-='", "'*='", "'/='", "'&='", "'|='", "'^='", "'%='", 
                     "'<<='", "'>>='", "'>>>='", "'->'", "'::'", "'@'", 
                     "'...'" ]

    symbolicNames = [ "<INVALID>", "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", 
                      "BYTE", "CASE", "CATCH", "CHAR", "CLASS", "CONST", 
                      "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE", "ENUM", 
                      "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR", "IF", 
                      "GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INT", 
                      "INTERFACE", "LONG", "NATIVE", "NEW", "PACKAGE", "PRIVATE", 
                      "PROTECTED", "PUBLIC", "RETURN", "SHORT", "STATIC", 
                      "STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED", "THIS", 
                      "THROW", "THROWS", "TRANSIENT", "TRY", "VOID", "VOLATILE", 
                      "WHILE", "MODULE", "OPEN", "REQUIRES", "EXPORTS", 
                      "OPENS", "TO", "USES", "PROVIDES", "WITH", "TRANSITIVE", 
                      "VAR", "YIELD", "RECORD", "SEALED", "PERMITS", "NON_SEALED", 
                      "SEMI", "COMMA", "DOT", "PAREN_S", "PAREN_E", "BLOCK_S", 
                      "BLOCK_E", "ARRAY_S", "ARRAY_E", "DECIMAL_LITERAL", 
                      "HEX_LITERAL", "OCT_LITERAL", "BINARY_LITERAL", "FLOAT_LITERAL", 
                      "HEX_FLOAT_LITERAL", "BOOL_LITERAL", "CHAR_LITERAL", 
                      "STRING_LITERAL", "TEXT_BLOCK", "NULL_LITERAL", "WS", 
                      "COMMENT", "LINE_COMMENT", "ASSIGN", "GT", "LT", "LOG_NOT", 
                      "TILDE", "QUESTION", "COLON", "EQUAL", "LE", "GE", 
                      "NOTEQUAL", "LOG_AND", "LOG_OR", "UNN_INC", "UNN_DEC", 
                      "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", "CARET", 
                      "MOD", "ADD_ASS", "SUB_ASS", "MUL_ASS", "DIV_ASS", 
                      "AND_ASS", "OR_ASS", "XOR_ASS", "MOD_ASS", "LSHIFT_ASS", 
                      "RSHIFT_ASS", "URSHIFT_ASS", "ARROW", "COLONCOLON", 
                      "AT", "ELLIPSIS", "IDENTIFIER" ]

    RULE_identifier = 0
    RULE_type_identifier = 1
    RULE_non_wild_card_type_arguments_or_diamond = 2
    RULE_non_wildcard_type_arguments = 3
    RULE_type_list = 4
    RULE_type_type = 5
    RULE_primitive_type = 6
    RULE_type_parameter = 7
    RULE_type_bound = 8
    RULE_type_argument = 9
    RULE_type_arguments = 10
    RULE_super_suffix = 11
    RULE_explicit_generic_invocation_suffix = 12
    RULE_arguments = 13
    RULE_class_or_interface_type = 14
    RULE_class_type = 15
    RULE_compilation_unit = 16
    RULE_package_declaration = 17
    RULE_import_declaration = 18
    RULE_module_declaration = 19
    RULE_type_declaration = 20
    RULE_module_body = 21
    RULE_module_directive = 22
    RULE_modifier = 23
    RULE_requires_modifier = 24
    RULE_class_or_interface_modifier = 25
    RULE_class_declaration = 26
    RULE_type_parameters = 27
    RULE_class_body = 28
    RULE_class_body_declaration = 29
    RULE_member_declaration = 30
    RULE_field_declaration = 31
    RULE_variable_declarators = 32
    RULE_variable_declarator = 33
    RULE_variable_declarator_id = 34
    RULE_variable_initializer = 35
    RULE_method_declaration = 36
    RULE_receiver_parameter = 37
    RULE_formal_parameter_list = 38
    RULE_formal_parameters = 39
    RULE_formal_parameter = 40
    RULE_variable_modifier = 41
    RULE_method_body = 42
    RULE_generic_constructor_declaration = 43
    RULE_constructor_declaration = 44
    RULE_enum_declaration = 45
    RULE_enum_constants = 46
    RULE_enum_constant = 47
    RULE_enum_body_declarations = 48
    RULE_record_declaration = 49
    RULE_record_header = 50
    RULE_record_component_list = 51
    RULE_record_component = 52
    RULE_record_body = 53
    RULE_compact_constructor_declaration = 54
    RULE_interface_declaration = 55
    RULE_interface_body = 56
    RULE_type_type_or_void = 57
    RULE_generic_method_declaration = 58
    RULE_interface_body_declaration = 59
    RULE_interface_member_declaration = 60
    RULE_const_declaration = 61
    RULE_constant_declarator = 62
    RULE_interface_method_declaration = 63
    RULE_interface_method_modifier = 64
    RULE_generic_interface_method_declaration = 65
    RULE_interface_common_body_declaration = 66
    RULE_default_value = 67
    RULE_alt_annotation_qualified_name = 68
    RULE_annotation = 69
    RULE_element_value_pairs = 70
    RULE_element_value_pair = 71
    RULE_element_value = 72
    RULE_element_value_array_initializer = 73
    RULE_annotation_type_declaration = 74
    RULE_annotation_type_body = 75
    RULE_annotation_type_element_declaration = 76
    RULE_annotation_type_element_rest = 77
    RULE_annotation_method_or_constant_rest = 78
    RULE_annotation_method_rest = 79
    RULE_annotation_constant_rest = 80
    RULE_array_initializer = 81
    RULE_block = 82
    RULE_block_statement = 83
    RULE_local_variable_declaration = 84
    RULE_statement = 85
    RULE_switch_rule_outcome = 86
    RULE_switch_block_statement_group = 87
    RULE_switch_label = 88
    RULE_for_init = 89
    RULE_for_control = 90
    RULE_enhanced_for_control = 91
    RULE_catch_clause = 92
    RULE_catch_type = 93
    RULE_finally_block = 94
    RULE_resource_specification = 95
    RULE_resources = 96
    RULE_resource = 97
    RULE_pattern = 98
    RULE_primary = 99
    RULE_literal = 100
    RULE_integer_literal = 101
    RULE_float_literal = 102
    RULE_type_arguments_or_diamond = 103
    RULE_expression = 104
    RULE_switch_expression = 105
    RULE_switch_labeled_rule = 106
    RULE_qualified_name_list = 107
    RULE_last_formal_parameter = 108
    RULE_qualified_name = 109
    RULE_local_type_declaration = 110
    RULE_par_expression = 111
    RULE_expression_list = 112
    RULE_method_call = 113
    RULE_guarded_pattern = 114
    RULE_creator = 115
    RULE_created_name = 116
    RULE_inner_creator = 117
    RULE_array_creator_rest = 118
    RULE_class_creator_rest = 119
    RULE_explicit_generic_invocation = 120

    ruleNames =  [ "identifier", "type_identifier", "non_wild_card_type_arguments_or_diamond", 
                   "non_wildcard_type_arguments", "type_list", "type_type", 
                   "primitive_type", "type_parameter", "type_bound", "type_argument", 
                   "type_arguments", "super_suffix", "explicit_generic_invocation_suffix", 
                   "arguments", "class_or_interface_type", "class_type", 
                   "compilation_unit", "package_declaration", "import_declaration", 
                   "module_declaration", "type_declaration", "module_body", 
                   "module_directive", "modifier", "requires_modifier", 
                   "class_or_interface_modifier", "class_declaration", "type_parameters", 
                   "class_body", "class_body_declaration", "member_declaration", 
                   "field_declaration", "variable_declarators", "variable_declarator", 
                   "variable_declarator_id", "variable_initializer", "method_declaration", 
                   "receiver_parameter", "formal_parameter_list", "formal_parameters", 
                   "formal_parameter", "variable_modifier", "method_body", 
                   "generic_constructor_declaration", "constructor_declaration", 
                   "enum_declaration", "enum_constants", "enum_constant", 
                   "enum_body_declarations", "record_declaration", "record_header", 
                   "record_component_list", "record_component", "record_body", 
                   "compact_constructor_declaration", "interface_declaration", 
                   "interface_body", "type_type_or_void", "generic_method_declaration", 
                   "interface_body_declaration", "interface_member_declaration", 
                   "const_declaration", "constant_declarator", "interface_method_declaration", 
                   "interface_method_modifier", "generic_interface_method_declaration", 
                   "interface_common_body_declaration", "default_value", 
                   "alt_annotation_qualified_name", "annotation", "element_value_pairs", 
                   "element_value_pair", "element_value", "element_value_array_initializer", 
                   "annotation_type_declaration", "annotation_type_body", 
                   "annotation_type_element_declaration", "annotation_type_element_rest", 
                   "annotation_method_or_constant_rest", "annotation_method_rest", 
                   "annotation_constant_rest", "array_initializer", "block", 
                   "block_statement", "local_variable_declaration", "statement", 
                   "switch_rule_outcome", "switch_block_statement_group", 
                   "switch_label", "for_init", "for_control", "enhanced_for_control", 
                   "catch_clause", "catch_type", "finally_block", "resource_specification", 
                   "resources", "resource", "pattern", "primary", "literal", 
                   "integer_literal", "float_literal", "type_arguments_or_diamond", 
                   "expression", "switch_expression", "switch_labeled_rule", 
                   "qualified_name_list", "last_formal_parameter", "qualified_name", 
                   "local_type_declaration", "par_expression", "expression_list", 
                   "method_call", "guarded_pattern", "creator", "created_name", 
                   "inner_creator", "array_creator_rest", "class_creator_rest", 
                   "explicit_generic_invocation" ]

    EOF = Token.EOF
    ABSTRACT=1
    ASSERT=2
    BOOLEAN=3
    BREAK=4
    BYTE=5
    CASE=6
    CATCH=7
    CHAR=8
    CLASS=9
    CONST=10
    CONTINUE=11
    DEFAULT=12
    DO=13
    DOUBLE=14
    ELSE=15
    ENUM=16
    EXTENDS=17
    FINAL=18
    FINALLY=19
    FLOAT=20
    FOR=21
    IF=22
    GOTO=23
    IMPLEMENTS=24
    IMPORT=25
    INSTANCEOF=26
    INT=27
    INTERFACE=28
    LONG=29
    NATIVE=30
    NEW=31
    PACKAGE=32
    PRIVATE=33
    PROTECTED=34
    PUBLIC=35
    RETURN=36
    SHORT=37
    STATIC=38
    STRICTFP=39
    SUPER=40
    SWITCH=41
    SYNCHRONIZED=42
    THIS=43
    THROW=44
    THROWS=45
    TRANSIENT=46
    TRY=47
    VOID=48
    VOLATILE=49
    WHILE=50
    MODULE=51
    OPEN=52
    REQUIRES=53
    EXPORTS=54
    OPENS=55
    TO=56
    USES=57
    PROVIDES=58
    WITH=59
    TRANSITIVE=60
    VAR=61
    YIELD=62
    RECORD=63
    SEALED=64
    PERMITS=65
    NON_SEALED=66
    SEMI=67
    COMMA=68
    DOT=69
    PAREN_S=70
    PAREN_E=71
    BLOCK_S=72
    BLOCK_E=73
    ARRAY_S=74
    ARRAY_E=75
    DECIMAL_LITERAL=76
    HEX_LITERAL=77
    OCT_LITERAL=78
    BINARY_LITERAL=79
    FLOAT_LITERAL=80
    HEX_FLOAT_LITERAL=81
    BOOL_LITERAL=82
    CHAR_LITERAL=83
    STRING_LITERAL=84
    TEXT_BLOCK=85
    NULL_LITERAL=86
    WS=87
    COMMENT=88
    LINE_COMMENT=89
    ASSIGN=90
    GT=91
    LT=92
    LOG_NOT=93
    TILDE=94
    QUESTION=95
    COLON=96
    EQUAL=97
    LE=98
    GE=99
    NOTEQUAL=100
    LOG_AND=101
    LOG_OR=102
    UNN_INC=103
    UNN_DEC=104
    ADD=105
    SUB=106
    MUL=107
    DIV=108
    BITAND=109
    BITOR=110
    CARET=111
    MOD=112
    ADD_ASS=113
    SUB_ASS=114
    MUL_ASS=115
    DIV_ASS=116
    AND_ASS=117
    OR_ASS=118
    XOR_ASS=119
    MOD_ASS=120
    LSHIFT_ASS=121
    RSHIFT_ASS=122
    URSHIFT_ASS=123
    ARROW=124
    COLONCOLON=125
    AT=126
    ELLIPSIS=127
    IDENTIFIER=128

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(JavaParser.IDENTIFIER, 0)

        def MODULE(self):
            return self.getToken(JavaParser.MODULE, 0)

        def OPEN(self):
            return self.getToken(JavaParser.OPEN, 0)

        def REQUIRES(self):
            return self.getToken(JavaParser.REQUIRES, 0)

        def EXPORTS(self):
            return self.getToken(JavaParser.EXPORTS, 0)

        def OPENS(self):
            return self.getToken(JavaParser.OPENS, 0)

        def TO(self):
            return self.getToken(JavaParser.TO, 0)

        def USES(self):
            return self.getToken(JavaParser.USES, 0)

        def PROVIDES(self):
            return self.getToken(JavaParser.PROVIDES, 0)

        def WITH(self):
            return self.getToken(JavaParser.WITH, 0)

        def TRANSITIVE(self):
            return self.getToken(JavaParser.TRANSITIVE, 0)

        def YIELD(self):
            return self.getToken(JavaParser.YIELD, 0)

        def SEALED(self):
            return self.getToken(JavaParser.SEALED, 0)

        def PERMITS(self):
            return self.getToken(JavaParser.PERMITS, 0)

        def RECORD(self):
            return self.getToken(JavaParser.RECORD, 0)

        def VAR(self):
            return self.getToken(JavaParser.VAR, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = JavaParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            _la = self._input.LA(1)
            if not(((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.IDENTIFIER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_identifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(JavaParser.IDENTIFIER, 0)

        def MODULE(self):
            return self.getToken(JavaParser.MODULE, 0)

        def OPEN(self):
            return self.getToken(JavaParser.OPEN, 0)

        def REQUIRES(self):
            return self.getToken(JavaParser.REQUIRES, 0)

        def EXPORTS(self):
            return self.getToken(JavaParser.EXPORTS, 0)

        def OPENS(self):
            return self.getToken(JavaParser.OPENS, 0)

        def TO(self):
            return self.getToken(JavaParser.TO, 0)

        def USES(self):
            return self.getToken(JavaParser.USES, 0)

        def PROVIDES(self):
            return self.getToken(JavaParser.PROVIDES, 0)

        def WITH(self):
            return self.getToken(JavaParser.WITH, 0)

        def TRANSITIVE(self):
            return self.getToken(JavaParser.TRANSITIVE, 0)

        def SEALED(self):
            return self.getToken(JavaParser.SEALED, 0)

        def PERMITS(self):
            return self.getToken(JavaParser.PERMITS, 0)

        def RECORD(self):
            return self.getToken(JavaParser.RECORD, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_type_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_identifier" ):
                listener.enterType_identifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_identifier" ):
                listener.exitType_identifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_identifier" ):
                return visitor.visitType_identifier(self)
            else:
                return visitor.visitChildren(self)




    def type_identifier(self):

        localctx = JavaParser.Type_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_type_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            _la = self._input.LA(1)
            if not(((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.IDENTIFIER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Non_wild_card_type_arguments_or_diamondContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(JavaParser.LT, 0)

        def GT(self):
            return self.getToken(JavaParser.GT, 0)

        def non_wildcard_type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Non_wildcard_type_argumentsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_non_wild_card_type_arguments_or_diamond

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_wild_card_type_arguments_or_diamond" ):
                listener.enterNon_wild_card_type_arguments_or_diamond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_wild_card_type_arguments_or_diamond" ):
                listener.exitNon_wild_card_type_arguments_or_diamond(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNon_wild_card_type_arguments_or_diamond" ):
                return visitor.visitNon_wild_card_type_arguments_or_diamond(self)
            else:
                return visitor.visitChildren(self)




    def non_wild_card_type_arguments_or_diamond(self):

        localctx = JavaParser.Non_wild_card_type_arguments_or_diamondContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_non_wild_card_type_arguments_or_diamond)
        try:
            self.state = 249
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 246
                self.match(JavaParser.LT)
                self.state = 247
                self.match(JavaParser.GT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 248
                self.non_wildcard_type_arguments()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Non_wildcard_type_argumentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(JavaParser.LT, 0)

        def type_list(self):
            return self.getTypedRuleContext(JavaParser.Type_listContext,0)


        def GT(self):
            return self.getToken(JavaParser.GT, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_non_wildcard_type_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_wildcard_type_arguments" ):
                listener.enterNon_wildcard_type_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_wildcard_type_arguments" ):
                listener.exitNon_wildcard_type_arguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNon_wildcard_type_arguments" ):
                return visitor.visitNon_wildcard_type_arguments(self)
            else:
                return visitor.visitChildren(self)




    def non_wildcard_type_arguments(self):

        localctx = JavaParser.Non_wildcard_type_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_non_wildcard_type_arguments)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.match(JavaParser.LT)
            self.state = 252
            self.type_list()
            self.state = 253
            self.match(JavaParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_typeContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_typeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_type_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_list" ):
                listener.enterType_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_list" ):
                listener.exitType_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_list" ):
                return visitor.visitType_list(self)
            else:
                return visitor.visitChildren(self)




    def type_list(self):

        localctx = JavaParser.Type_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_type_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 255
            self.type_type()
            self.state = 260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 256
                self.match(JavaParser.COMMA)
                self.state = 257
                self.type_type()
                self.state = 262
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def class_or_interface_type(self):
            return self.getTypedRuleContext(JavaParser.Class_or_interface_typeContext,0)


        def primitive_type(self):
            return self.getTypedRuleContext(JavaParser.Primitive_typeContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def ARRAY_S(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_S)
            else:
                return self.getToken(JavaParser.ARRAY_S, i)

        def ARRAY_E(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_E)
            else:
                return self.getToken(JavaParser.ARRAY_E, i)

        def getRuleIndex(self):
            return JavaParser.RULE_type_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_type" ):
                listener.enterType_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_type" ):
                listener.exitType_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_type" ):
                return visitor.visitType_type(self)
            else:
                return visitor.visitChildren(self)




    def type_type(self):

        localctx = JavaParser.Type_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_type_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 263
                    self.annotation() 
                self.state = 268
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

            self.state = 271
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.IDENTIFIER]:
                self.state = 269
                self.class_or_interface_type()
                pass
            elif token in [JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.DOUBLE, JavaParser.FLOAT, JavaParser.INT, JavaParser.LONG, JavaParser.SHORT]:
                self.state = 270
                self.primitive_type()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 283
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 276
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                        self.state = 273
                        self.annotation()
                        self.state = 278
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 279
                    self.match(JavaParser.ARRAY_S)
                    self.state = 280
                    self.match(JavaParser.ARRAY_E) 
                self.state = 285
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Primitive_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(JavaParser.BOOLEAN, 0)

        def CHAR(self):
            return self.getToken(JavaParser.CHAR, 0)

        def BYTE(self):
            return self.getToken(JavaParser.BYTE, 0)

        def SHORT(self):
            return self.getToken(JavaParser.SHORT, 0)

        def INT(self):
            return self.getToken(JavaParser.INT, 0)

        def LONG(self):
            return self.getToken(JavaParser.LONG, 0)

        def FLOAT(self):
            return self.getToken(JavaParser.FLOAT, 0)

        def DOUBLE(self):
            return self.getToken(JavaParser.DOUBLE, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_primitive_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimitive_type" ):
                listener.enterPrimitive_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimitive_type" ):
                listener.exitPrimitive_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimitive_type" ):
                return visitor.visitPrimitive_type(self)
            else:
                return visitor.visitChildren(self)




    def primitive_type(self):

        localctx = JavaParser.Primitive_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_primitive_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.SHORT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def EXTENDS(self):
            return self.getToken(JavaParser.EXTENDS, 0)

        def type_bound(self):
            return self.getTypedRuleContext(JavaParser.Type_boundContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_type_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_parameter" ):
                listener.enterType_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_parameter" ):
                listener.exitType_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_parameter" ):
                return visitor.visitType_parameter(self)
            else:
                return visitor.visitChildren(self)




    def type_parameter(self):

        localctx = JavaParser.Type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_type_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 288
                    self.annotation() 
                self.state = 293
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 294
            self.identifier()
            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.EXTENDS:
                self.state = 295
                self.match(JavaParser.EXTENDS)
                self.state = 299
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 296
                        self.annotation() 
                    self.state = 301
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                self.state = 302
                self.type_bound()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_boundContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_typeContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_typeContext,i)


        def BITAND(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.BITAND)
            else:
                return self.getToken(JavaParser.BITAND, i)

        def getRuleIndex(self):
            return JavaParser.RULE_type_bound

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_bound" ):
                listener.enterType_bound(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_bound" ):
                listener.exitType_bound(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_bound" ):
                return visitor.visitType_bound(self)
            else:
                return visitor.visitChildren(self)




    def type_bound(self):

        localctx = JavaParser.Type_boundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_type_bound)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.type_type()
            self.state = 310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.BITAND:
                self.state = 306
                self.match(JavaParser.BITAND)
                self.state = 307
                self.type_type()
                self.state = 312
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_argumentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def QUESTION(self):
            return self.getToken(JavaParser.QUESTION, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def EXTENDS(self):
            return self.getToken(JavaParser.EXTENDS, 0)

        def SUPER(self):
            return self.getToken(JavaParser.SUPER, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_type_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_argument" ):
                listener.enterType_argument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_argument" ):
                listener.exitType_argument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_argument" ):
                return visitor.visitType_argument(self)
            else:
                return visitor.visitChildren(self)




    def type_argument(self):

        localctx = JavaParser.Type_argumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_type_argument)
        self._la = 0 # Token type
        try:
            self.state = 325
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 313
                self.type_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 317
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                    self.state = 314
                    self.annotation()
                    self.state = 319
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 320
                self.match(JavaParser.QUESTION)
                self.state = 323
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.EXTENDS or _la==JavaParser.SUPER:
                    self.state = 321
                    _la = self._input.LA(1)
                    if not(_la==JavaParser.EXTENDS or _la==JavaParser.SUPER):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 322
                    self.type_type()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_argumentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(JavaParser.LT, 0)

        def type_argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_argumentContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_argumentContext,i)


        def GT(self):
            return self.getToken(JavaParser.GT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_type_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_arguments" ):
                listener.enterType_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_arguments" ):
                listener.exitType_arguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_arguments" ):
                return visitor.visitType_arguments(self)
            else:
                return visitor.visitChildren(self)




    def type_arguments(self):

        localctx = JavaParser.Type_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_type_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.match(JavaParser.LT)
            self.state = 328
            self.type_argument()
            self.state = 333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 329
                self.match(JavaParser.COMMA)
                self.state = 330
                self.type_argument()
                self.state = 335
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 336
            self.match(JavaParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Super_suffixContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arguments(self):
            return self.getTypedRuleContext(JavaParser.ArgumentsContext,0)


        def DOT(self):
            return self.getToken(JavaParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Type_argumentsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_super_suffix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuper_suffix" ):
                listener.enterSuper_suffix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuper_suffix" ):
                listener.exitSuper_suffix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSuper_suffix" ):
                return visitor.visitSuper_suffix(self)
            else:
                return visitor.visitChildren(self)




    def super_suffix(self):

        localctx = JavaParser.Super_suffixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_super_suffix)
        self._la = 0 # Token type
        try:
            self.state = 347
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.PAREN_S]:
                self.enterOuterAlt(localctx, 1)
                self.state = 338
                self.arguments()
                pass
            elif token in [JavaParser.DOT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 339
                self.match(JavaParser.DOT)
                self.state = 341
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.LT:
                    self.state = 340
                    self.type_arguments()


                self.state = 343
                self.identifier()
                self.state = 345
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                if la_ == 1:
                    self.state = 344
                    self.arguments()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Explicit_generic_invocation_suffixContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUPER(self):
            return self.getToken(JavaParser.SUPER, 0)

        def super_suffix(self):
            return self.getTypedRuleContext(JavaParser.Super_suffixContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def arguments(self):
            return self.getTypedRuleContext(JavaParser.ArgumentsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_explicit_generic_invocation_suffix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplicit_generic_invocation_suffix" ):
                listener.enterExplicit_generic_invocation_suffix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplicit_generic_invocation_suffix" ):
                listener.exitExplicit_generic_invocation_suffix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplicit_generic_invocation_suffix" ):
                return visitor.visitExplicit_generic_invocation_suffix(self)
            else:
                return visitor.visitChildren(self)




    def explicit_generic_invocation_suffix(self):

        localctx = JavaParser.Explicit_generic_invocation_suffixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_explicit_generic_invocation_suffix)
        try:
            self.state = 354
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.SUPER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 349
                self.match(JavaParser.SUPER)
                self.state = 350
                self.super_suffix()
                pass
            elif token in [JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 351
                self.identifier()
                self.state = 352
                self.arguments()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def expression_list(self):
            return self.getTypedRuleContext(JavaParser.Expression_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArguments" ):
                listener.enterArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArguments" ):
                listener.exitArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArguments" ):
                return visitor.visitArguments(self)
            else:
                return visitor.visitChildren(self)




    def arguments(self):

        localctx = JavaParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 356
            self.match(JavaParser.PAREN_S)
            self.state = 358
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                self.state = 357
                self.expression_list()


            self.state = 360
            self.match(JavaParser.PAREN_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_or_interface_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_identifier(self):
            return self.getTypedRuleContext(JavaParser.Type_identifierContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.IdentifierContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.DOT)
            else:
                return self.getToken(JavaParser.DOT, i)

        def type_arguments(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_argumentsContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_argumentsContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_class_or_interface_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_or_interface_type" ):
                listener.enterClass_or_interface_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_or_interface_type" ):
                listener.exitClass_or_interface_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_or_interface_type" ):
                return visitor.visitClass_or_interface_type(self)
            else:
                return visitor.visitChildren(self)




    def class_or_interface_type(self):

        localctx = JavaParser.Class_or_interface_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_class_or_interface_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 370
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 362
                    self.identifier()
                    self.state = 364
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==JavaParser.LT:
                        self.state = 363
                        self.type_arguments()


                    self.state = 366
                    self.match(JavaParser.DOT) 
                self.state = 372
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 373
            self.type_identifier()
            self.state = 375
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 374
                self.type_arguments()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def class_or_interface_type(self):
            return self.getTypedRuleContext(JavaParser.Class_or_interface_typeContext,0)


        def DOT(self):
            return self.getToken(JavaParser.DOT, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Type_argumentsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_class_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_type" ):
                listener.enterClass_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_type" ):
                listener.exitClass_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_type" ):
                return visitor.visitClass_type(self)
            else:
                return visitor.visitChildren(self)




    def class_type(self):

        localctx = JavaParser.Class_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_class_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 380
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 377
                self.class_or_interface_type()
                self.state = 378
                self.match(JavaParser.DOT)


            self.state = 385
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,23,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 382
                    self.annotation() 
                self.state = 387
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

            self.state = 388
            self.identifier()
            self.state = 390
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.LT:
                self.state = 389
                self.type_arguments()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compilation_unitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def package_declaration(self):
            return self.getTypedRuleContext(JavaParser.Package_declarationContext,0)


        def import_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Import_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Import_declarationContext,i)


        def type_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_declarationContext,i)


        def module_declaration(self):
            return self.getTypedRuleContext(JavaParser.Module_declarationContext,0)


        def EOF(self):
            return self.getToken(JavaParser.EOF, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_compilation_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilation_unit" ):
                listener.enterCompilation_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilation_unit" ):
                listener.exitCompilation_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilation_unit" ):
                return visitor.visitCompilation_unit(self)
            else:
                return visitor.visitChildren(self)




    def compilation_unit(self):

        localctx = JavaParser.Compilation_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_compilation_unit)
        self._la = 0 # Token type
        try:
            self.state = 410
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 393
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
                if la_ == 1:
                    self.state = 392
                    self.package_declaration()


                self.state = 398
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==JavaParser.IMPORT:
                    self.state = 395
                    self.import_declaration()
                    self.state = 400
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 404
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.ENUM - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                    self.state = 401
                    self.type_declaration()
                    self.state = 406
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 407
                self.module_declaration()
                self.state = 408
                self.match(JavaParser.EOF)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Package_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PACKAGE(self):
            return self.getToken(JavaParser.PACKAGE, 0)

        def qualified_name(self):
            return self.getTypedRuleContext(JavaParser.Qualified_nameContext,0)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_package_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackage_declaration" ):
                listener.enterPackage_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackage_declaration" ):
                listener.exitPackage_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackage_declaration" ):
                return visitor.visitPackage_declaration(self)
            else:
                return visitor.visitChildren(self)




    def package_declaration(self):

        localctx = JavaParser.Package_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_package_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                self.state = 412
                self.annotation()
                self.state = 417
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 418
            self.match(JavaParser.PACKAGE)
            self.state = 419
            self.qualified_name()
            self.state = 420
            self.match(JavaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Import_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(JavaParser.IMPORT, 0)

        def qualified_name(self):
            return self.getTypedRuleContext(JavaParser.Qualified_nameContext,0)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def STATIC(self):
            return self.getToken(JavaParser.STATIC, 0)

        def DOT(self):
            return self.getToken(JavaParser.DOT, 0)

        def MUL(self):
            return self.getToken(JavaParser.MUL, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_import_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImport_declaration" ):
                listener.enterImport_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImport_declaration" ):
                listener.exitImport_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImport_declaration" ):
                return visitor.visitImport_declaration(self)
            else:
                return visitor.visitChildren(self)




    def import_declaration(self):

        localctx = JavaParser.Import_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_import_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.match(JavaParser.IMPORT)
            self.state = 424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.STATIC:
                self.state = 423
                self.match(JavaParser.STATIC)


            self.state = 426
            self.qualified_name()
            self.state = 429
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.DOT:
                self.state = 427
                self.match(JavaParser.DOT)
                self.state = 428
                self.match(JavaParser.MUL)


            self.state = 431
            self.match(JavaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Module_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODULE(self):
            return self.getToken(JavaParser.MODULE, 0)

        def qualified_name(self):
            return self.getTypedRuleContext(JavaParser.Qualified_nameContext,0)


        def module_body(self):
            return self.getTypedRuleContext(JavaParser.Module_bodyContext,0)


        def OPEN(self):
            return self.getToken(JavaParser.OPEN, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_module_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_declaration" ):
                listener.enterModule_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_declaration" ):
                listener.exitModule_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_declaration" ):
                return visitor.visitModule_declaration(self)
            else:
                return visitor.visitChildren(self)




    def module_declaration(self):

        localctx = JavaParser.Module_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_module_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.OPEN:
                self.state = 433
                self.match(JavaParser.OPEN)


            self.state = 436
            self.match(JavaParser.MODULE)
            self.state = 437
            self.qualified_name()
            self.state = 438
            self.module_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def class_declaration(self):
            return self.getTypedRuleContext(JavaParser.Class_declarationContext,0)


        def enum_declaration(self):
            return self.getTypedRuleContext(JavaParser.Enum_declarationContext,0)


        def interface_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_declarationContext,0)


        def annotation_type_declaration(self):
            return self.getTypedRuleContext(JavaParser.Annotation_type_declarationContext,0)


        def record_declaration(self):
            return self.getTypedRuleContext(JavaParser.Record_declarationContext,0)


        def class_or_interface_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Class_or_interface_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Class_or_interface_modifierContext,i)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_type_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_declaration" ):
                listener.enterType_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_declaration" ):
                listener.exitType_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_declaration" ):
                return visitor.visitType_declaration(self)
            else:
                return visitor.visitChildren(self)




    def type_declaration(self):

        localctx = JavaParser.Type_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_type_declaration)
        try:
            self.state = 454
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.ABSTRACT, JavaParser.CLASS, JavaParser.ENUM, JavaParser.FINAL, JavaParser.INTERFACE, JavaParser.PRIVATE, JavaParser.PROTECTED, JavaParser.PUBLIC, JavaParser.STATIC, JavaParser.STRICTFP, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.NON_SEALED, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 443
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 440
                        self.class_or_interface_modifier() 
                    self.state = 445
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                self.state = 451
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [JavaParser.CLASS]:
                    self.state = 446
                    self.class_declaration()
                    pass
                elif token in [JavaParser.ENUM]:
                    self.state = 447
                    self.enum_declaration()
                    pass
                elif token in [JavaParser.INTERFACE]:
                    self.state = 448
                    self.interface_declaration()
                    pass
                elif token in [JavaParser.AT]:
                    self.state = 449
                    self.annotation_type_declaration()
                    pass
                elif token in [JavaParser.RECORD]:
                    self.state = 450
                    self.record_declaration()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [JavaParser.SEMI]:
                self.enterOuterAlt(localctx, 2)
                self.state = 453
                self.match(JavaParser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Module_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def module_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Module_directiveContext)
            else:
                return self.getTypedRuleContext(JavaParser.Module_directiveContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_module_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_body" ):
                listener.enterModule_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_body" ):
                listener.exitModule_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_body" ):
                return visitor.visitModule_body(self)
            else:
                return visitor.visitChildren(self)




    def module_body(self):

        localctx = JavaParser.Module_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_module_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 456
            self.match(JavaParser.BLOCK_S)
            self.state = 460
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JavaParser.REQUIRES) | (1 << JavaParser.EXPORTS) | (1 << JavaParser.OPENS) | (1 << JavaParser.USES) | (1 << JavaParser.PROVIDES))) != 0):
                self.state = 457
                self.module_directive()
                self.state = 462
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 463
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Module_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRES(self):
            return self.getToken(JavaParser.REQUIRES, 0)

        def qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Qualified_nameContext)
            else:
                return self.getTypedRuleContext(JavaParser.Qualified_nameContext,i)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def requires_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Requires_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Requires_modifierContext,i)


        def EXPORTS(self):
            return self.getToken(JavaParser.EXPORTS, 0)

        def TO(self):
            return self.getToken(JavaParser.TO, 0)

        def OPENS(self):
            return self.getToken(JavaParser.OPENS, 0)

        def USES(self):
            return self.getToken(JavaParser.USES, 0)

        def PROVIDES(self):
            return self.getToken(JavaParser.PROVIDES, 0)

        def WITH(self):
            return self.getToken(JavaParser.WITH, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_module_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule_directive" ):
                listener.enterModule_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule_directive" ):
                listener.exitModule_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_directive" ):
                return visitor.visitModule_directive(self)
            else:
                return visitor.visitChildren(self)




    def module_directive(self):

        localctx = JavaParser.Module_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_module_directive)
        self._la = 0 # Token type
        try:
            self.state = 501
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.REQUIRES]:
                self.enterOuterAlt(localctx, 1)
                self.state = 465
                self.match(JavaParser.REQUIRES)
                self.state = 469
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,37,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 466
                        self.requires_modifier() 
                    self.state = 471
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

                self.state = 472
                self.qualified_name()
                self.state = 473
                self.match(JavaParser.SEMI)
                pass
            elif token in [JavaParser.EXPORTS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 475
                self.match(JavaParser.EXPORTS)
                self.state = 476
                self.qualified_name()
                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.TO:
                    self.state = 477
                    self.match(JavaParser.TO)
                    self.state = 478
                    self.qualified_name()


                self.state = 481
                self.match(JavaParser.SEMI)
                pass
            elif token in [JavaParser.OPENS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 483
                self.match(JavaParser.OPENS)
                self.state = 484
                self.qualified_name()
                self.state = 487
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.TO:
                    self.state = 485
                    self.match(JavaParser.TO)
                    self.state = 486
                    self.qualified_name()


                self.state = 489
                self.match(JavaParser.SEMI)
                pass
            elif token in [JavaParser.USES]:
                self.enterOuterAlt(localctx, 4)
                self.state = 491
                self.match(JavaParser.USES)
                self.state = 492
                self.qualified_name()
                self.state = 493
                self.match(JavaParser.SEMI)
                pass
            elif token in [JavaParser.PROVIDES]:
                self.enterOuterAlt(localctx, 5)
                self.state = 495
                self.match(JavaParser.PROVIDES)
                self.state = 496
                self.qualified_name()
                self.state = 497
                self.match(JavaParser.WITH)
                self.state = 498
                self.qualified_name()
                self.state = 499
                self.match(JavaParser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def class_or_interface_modifier(self):
            return self.getTypedRuleContext(JavaParser.Class_or_interface_modifierContext,0)


        def NATIVE(self):
            return self.getToken(JavaParser.NATIVE, 0)

        def SYNCHRONIZED(self):
            return self.getToken(JavaParser.SYNCHRONIZED, 0)

        def TRANSIENT(self):
            return self.getToken(JavaParser.TRANSIENT, 0)

        def VOLATILE(self):
            return self.getToken(JavaParser.VOLATILE, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = JavaParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_modifier)
        try:
            self.state = 508
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.ABSTRACT, JavaParser.FINAL, JavaParser.PRIVATE, JavaParser.PROTECTED, JavaParser.PUBLIC, JavaParser.STATIC, JavaParser.STRICTFP, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.NON_SEALED, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 503
                self.class_or_interface_modifier()
                pass
            elif token in [JavaParser.NATIVE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 504
                self.match(JavaParser.NATIVE)
                pass
            elif token in [JavaParser.SYNCHRONIZED]:
                self.enterOuterAlt(localctx, 3)
                self.state = 505
                self.match(JavaParser.SYNCHRONIZED)
                pass
            elif token in [JavaParser.TRANSIENT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 506
                self.match(JavaParser.TRANSIENT)
                pass
            elif token in [JavaParser.VOLATILE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 507
                self.match(JavaParser.VOLATILE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Requires_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRANSITIVE(self):
            return self.getToken(JavaParser.TRANSITIVE, 0)

        def STATIC(self):
            return self.getToken(JavaParser.STATIC, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_requires_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequires_modifier" ):
                listener.enterRequires_modifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequires_modifier" ):
                listener.exitRequires_modifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequires_modifier" ):
                return visitor.visitRequires_modifier(self)
            else:
                return visitor.visitChildren(self)




    def requires_modifier(self):

        localctx = JavaParser.Requires_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_requires_modifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 510
            _la = self._input.LA(1)
            if not(_la==JavaParser.STATIC or _la==JavaParser.TRANSITIVE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_or_interface_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(JavaParser.AnnotationContext,0)


        def PUBLIC(self):
            return self.getToken(JavaParser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(JavaParser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(JavaParser.PRIVATE, 0)

        def STATIC(self):
            return self.getToken(JavaParser.STATIC, 0)

        def ABSTRACT(self):
            return self.getToken(JavaParser.ABSTRACT, 0)

        def FINAL(self):
            return self.getToken(JavaParser.FINAL, 0)

        def STRICTFP(self):
            return self.getToken(JavaParser.STRICTFP, 0)

        def SEALED(self):
            return self.getToken(JavaParser.SEALED, 0)

        def NON_SEALED(self):
            return self.getToken(JavaParser.NON_SEALED, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_class_or_interface_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_or_interface_modifier" ):
                listener.enterClass_or_interface_modifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_or_interface_modifier" ):
                listener.exitClass_or_interface_modifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_or_interface_modifier" ):
                return visitor.visitClass_or_interface_modifier(self)
            else:
                return visitor.visitChildren(self)




    def class_or_interface_modifier(self):

        localctx = JavaParser.Class_or_interface_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_class_or_interface_modifier)
        try:
            self.state = 522
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 512
                self.annotation()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 513
                self.match(JavaParser.PUBLIC)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 514
                self.match(JavaParser.PROTECTED)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 515
                self.match(JavaParser.PRIVATE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 516
                self.match(JavaParser.STATIC)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 517
                self.match(JavaParser.ABSTRACT)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 518
                self.match(JavaParser.FINAL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 519
                self.match(JavaParser.STRICTFP)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 520
                self.match(JavaParser.SEALED)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 521
                self.match(JavaParser.NON_SEALED)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(JavaParser.CLASS, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def class_body(self):
            return self.getTypedRuleContext(JavaParser.Class_bodyContext,0)


        def type_parameters(self):
            return self.getTypedRuleContext(JavaParser.Type_parametersContext,0)


        def EXTENDS(self):
            return self.getToken(JavaParser.EXTENDS, 0)

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def IMPLEMENTS(self):
            return self.getToken(JavaParser.IMPLEMENTS, 0)

        def type_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_listContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_listContext,i)


        def PERMITS(self):
            return self.getToken(JavaParser.PERMITS, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_class_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_declaration" ):
                listener.enterClass_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_declaration" ):
                listener.exitClass_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_declaration" ):
                return visitor.visitClass_declaration(self)
            else:
                return visitor.visitChildren(self)




    def class_declaration(self):

        localctx = JavaParser.Class_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_class_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 524
            self.match(JavaParser.CLASS)
            self.state = 525
            self.identifier()
            self.state = 527
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.LT:
                self.state = 526
                self.type_parameters()


            self.state = 531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.EXTENDS:
                self.state = 529
                self.match(JavaParser.EXTENDS)
                self.state = 530
                self.type_type()


            self.state = 535
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.IMPLEMENTS:
                self.state = 533
                self.match(JavaParser.IMPLEMENTS)
                self.state = 534
                self.type_list()


            self.state = 539
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.PERMITS:
                self.state = 537
                self.match(JavaParser.PERMITS)
                self.state = 538
                self.type_list()


            self.state = 541
            self.class_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(JavaParser.LT, 0)

        def type_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_parameterContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_parameterContext,i)


        def GT(self):
            return self.getToken(JavaParser.GT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_type_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_parameters" ):
                listener.enterType_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_parameters" ):
                listener.exitType_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_parameters" ):
                return visitor.visitType_parameters(self)
            else:
                return visitor.visitChildren(self)




    def type_parameters(self):

        localctx = JavaParser.Type_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_type_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.match(JavaParser.LT)
            self.state = 544
            self.type_parameter()
            self.state = 549
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 545
                self.match(JavaParser.COMMA)
                self.state = 546
                self.type_parameter()
                self.state = 551
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 552
            self.match(JavaParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def class_body_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Class_body_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Class_body_declarationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_class_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_body" ):
                listener.enterClass_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_body" ):
                listener.exitClass_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_body" ):
                return visitor.visitClass_body(self)
            else:
                return visitor.visitChildren(self)




    def class_body(self):

        localctx = JavaParser.Class_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_class_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.match(JavaParser.BLOCK_S)
            self.state = 558
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.ENUM - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NATIVE - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.TRANSIENT - 1)) | (1 << (JavaParser.VOID - 1)) | (1 << (JavaParser.VOLATILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.BLOCK_S - 65)) | (1 << (JavaParser.LT - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                self.state = 555
                self.class_body_declaration()
                self.state = 560
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 561
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_body_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def STATIC(self):
            return self.getToken(JavaParser.STATIC, 0)

        def member_declaration(self):
            return self.getTypedRuleContext(JavaParser.Member_declarationContext,0)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.ModifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_class_body_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_body_declaration" ):
                listener.enterClass_body_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_body_declaration" ):
                listener.exitClass_body_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_body_declaration" ):
                return visitor.visitClass_body_declaration(self)
            else:
                return visitor.visitChildren(self)




    def class_body_declaration(self):

        localctx = JavaParser.Class_body_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_class_body_declaration)
        self._la = 0 # Token type
        try:
            self.state = 575
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 563
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 565
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.STATIC:
                    self.state = 564
                    self.match(JavaParser.STATIC)


                self.state = 567
                self.block()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 571
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,50,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 568
                        self.modifier() 
                    self.state = 573
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,50,self._ctx)

                self.state = 574
                self.member_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def record_declaration(self):
            return self.getTypedRuleContext(JavaParser.Record_declarationContext,0)


        def method_declaration(self):
            return self.getTypedRuleContext(JavaParser.Method_declarationContext,0)


        def generic_method_declaration(self):
            return self.getTypedRuleContext(JavaParser.Generic_method_declarationContext,0)


        def field_declaration(self):
            return self.getTypedRuleContext(JavaParser.Field_declarationContext,0)


        def constructor_declaration(self):
            return self.getTypedRuleContext(JavaParser.Constructor_declarationContext,0)


        def generic_constructor_declaration(self):
            return self.getTypedRuleContext(JavaParser.Generic_constructor_declarationContext,0)


        def interface_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_declarationContext,0)


        def annotation_type_declaration(self):
            return self.getTypedRuleContext(JavaParser.Annotation_type_declarationContext,0)


        def class_declaration(self):
            return self.getTypedRuleContext(JavaParser.Class_declarationContext,0)


        def enum_declaration(self):
            return self.getTypedRuleContext(JavaParser.Enum_declarationContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_member_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMember_declaration" ):
                listener.enterMember_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMember_declaration" ):
                listener.exitMember_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMember_declaration" ):
                return visitor.visitMember_declaration(self)
            else:
                return visitor.visitChildren(self)




    def member_declaration(self):

        localctx = JavaParser.Member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_member_declaration)
        try:
            self.state = 587
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 577
                self.record_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 578
                self.method_declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 579
                self.generic_method_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 580
                self.field_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 581
                self.constructor_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 582
                self.generic_constructor_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 583
                self.interface_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 584
                self.annotation_type_declaration()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 585
                self.class_declaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 586
                self.enum_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Field_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def variable_declarators(self):
            return self.getTypedRuleContext(JavaParser.Variable_declaratorsContext,0)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_field_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterField_declaration" ):
                listener.enterField_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitField_declaration" ):
                listener.exitField_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitField_declaration" ):
                return visitor.visitField_declaration(self)
            else:
                return visitor.visitChildren(self)




    def field_declaration(self):

        localctx = JavaParser.Field_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_field_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            self.type_type()
            self.state = 590
            self.variable_declarators()
            self.state = 591
            self.match(JavaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declaratorsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_declarator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_declaratorContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_declaratorContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_variable_declarators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarators" ):
                listener.enterVariable_declarators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarators" ):
                listener.exitVariable_declarators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_declarators" ):
                return visitor.visitVariable_declarators(self)
            else:
                return visitor.visitChildren(self)




    def variable_declarators(self):

        localctx = JavaParser.Variable_declaratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_variable_declarators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.variable_declarator()
            self.state = 598
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 594
                self.match(JavaParser.COMMA)
                self.state = 595
                self.variable_declarator()
                self.state = 600
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_declarator_id(self):
            return self.getTypedRuleContext(JavaParser.Variable_declarator_idContext,0)


        def ASSIGN(self):
            return self.getToken(JavaParser.ASSIGN, 0)

        def variable_initializer(self):
            return self.getTypedRuleContext(JavaParser.Variable_initializerContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_variable_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarator" ):
                listener.enterVariable_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarator" ):
                listener.exitVariable_declarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_declarator" ):
                return visitor.visitVariable_declarator(self)
            else:
                return visitor.visitChildren(self)




    def variable_declarator(self):

        localctx = JavaParser.Variable_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_variable_declarator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 601
            self.variable_declarator_id()
            self.state = 604
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.ASSIGN:
                self.state = 602
                self.match(JavaParser.ASSIGN)
                self.state = 603
                self.variable_initializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declarator_idContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def ARRAY_S(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_S)
            else:
                return self.getToken(JavaParser.ARRAY_S, i)

        def ARRAY_E(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_E)
            else:
                return self.getToken(JavaParser.ARRAY_E, i)

        def getRuleIndex(self):
            return JavaParser.RULE_variable_declarator_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarator_id" ):
                listener.enterVariable_declarator_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarator_id" ):
                listener.exitVariable_declarator_id(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_declarator_id" ):
                return visitor.visitVariable_declarator_id(self)
            else:
                return visitor.visitChildren(self)




    def variable_declarator_id(self):

        localctx = JavaParser.Variable_declarator_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_variable_declarator_id)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            self.identifier()
            self.state = 611
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.ARRAY_S:
                self.state = 607
                self.match(JavaParser.ARRAY_S)
                self.state = 608
                self.match(JavaParser.ARRAY_E)
                self.state = 613
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def array_initializer(self):
            return self.getTypedRuleContext(JavaParser.Array_initializerContext,0)


        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_variable_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_initializer" ):
                listener.enterVariable_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_initializer" ):
                listener.exitVariable_initializer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_initializer" ):
                return visitor.visitVariable_initializer(self)
            else:
                return visitor.visitChildren(self)




    def variable_initializer(self):

        localctx = JavaParser.Variable_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_variable_initializer)
        try:
            self.state = 616
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.BLOCK_S]:
                self.enterOuterAlt(localctx, 1)
                self.state = 614
                self.array_initializer()
                pass
            elif token in [JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.DOUBLE, JavaParser.FLOAT, JavaParser.INT, JavaParser.LONG, JavaParser.NEW, JavaParser.SHORT, JavaParser.SUPER, JavaParser.SWITCH, JavaParser.THIS, JavaParser.VOID, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.PAREN_S, JavaParser.DECIMAL_LITERAL, JavaParser.HEX_LITERAL, JavaParser.OCT_LITERAL, JavaParser.BINARY_LITERAL, JavaParser.FLOAT_LITERAL, JavaParser.HEX_FLOAT_LITERAL, JavaParser.BOOL_LITERAL, JavaParser.CHAR_LITERAL, JavaParser.STRING_LITERAL, JavaParser.TEXT_BLOCK, JavaParser.NULL_LITERAL, JavaParser.LT, JavaParser.LOG_NOT, JavaParser.TILDE, JavaParser.UNN_INC, JavaParser.UNN_DEC, JavaParser.ADD, JavaParser.SUB, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 615
                self.expression(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Method_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type_or_void(self):
            return self.getTypedRuleContext(JavaParser.Type_type_or_voidContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def formal_parameters(self):
            return self.getTypedRuleContext(JavaParser.Formal_parametersContext,0)


        def method_body(self):
            return self.getTypedRuleContext(JavaParser.Method_bodyContext,0)


        def ARRAY_S(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_S)
            else:
                return self.getToken(JavaParser.ARRAY_S, i)

        def ARRAY_E(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_E)
            else:
                return self.getToken(JavaParser.ARRAY_E, i)

        def THROWS(self):
            return self.getToken(JavaParser.THROWS, 0)

        def qualified_name_list(self):
            return self.getTypedRuleContext(JavaParser.Qualified_name_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_method_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethod_declaration" ):
                listener.enterMethod_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethod_declaration" ):
                listener.exitMethod_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethod_declaration" ):
                return visitor.visitMethod_declaration(self)
            else:
                return visitor.visitChildren(self)




    def method_declaration(self):

        localctx = JavaParser.Method_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_method_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 618
            self.type_type_or_void()
            self.state = 619
            self.identifier()
            self.state = 620
            self.formal_parameters()
            self.state = 625
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.ARRAY_S:
                self.state = 621
                self.match(JavaParser.ARRAY_S)
                self.state = 622
                self.match(JavaParser.ARRAY_E)
                self.state = 627
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 630
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.THROWS:
                self.state = 628
                self.match(JavaParser.THROWS)
                self.state = 629
                self.qualified_name_list()


            self.state = 632
            self.method_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Receiver_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def THIS(self):
            return self.getToken(JavaParser.THIS, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.IdentifierContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.DOT)
            else:
                return self.getToken(JavaParser.DOT, i)

        def getRuleIndex(self):
            return JavaParser.RULE_receiver_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReceiver_parameter" ):
                listener.enterReceiver_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReceiver_parameter" ):
                listener.exitReceiver_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReceiver_parameter" ):
                return visitor.visitReceiver_parameter(self)
            else:
                return visitor.visitChildren(self)




    def receiver_parameter(self):

        localctx = JavaParser.Receiver_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_receiver_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 634
            self.type_type()
            self.state = 640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.IDENTIFIER:
                self.state = 635
                self.identifier()
                self.state = 636
                self.match(JavaParser.DOT)
                self.state = 642
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 643
            self.match(JavaParser.THIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formal_parameter_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formal_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Formal_parameterContext)
            else:
                return self.getTypedRuleContext(JavaParser.Formal_parameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def last_formal_parameter(self):
            return self.getTypedRuleContext(JavaParser.Last_formal_parameterContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_formal_parameter_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormal_parameter_list" ):
                listener.enterFormal_parameter_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormal_parameter_list" ):
                listener.exitFormal_parameter_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormal_parameter_list" ):
                return visitor.visitFormal_parameter_list(self)
            else:
                return visitor.visitChildren(self)




    def formal_parameter_list(self):

        localctx = JavaParser.Formal_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_formal_parameter_list)
        self._la = 0 # Token type
        try:
            self.state = 658
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 645
                self.formal_parameter()
                self.state = 650
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,60,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 646
                        self.match(JavaParser.COMMA)
                        self.state = 647
                        self.formal_parameter() 
                    self.state = 652
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,60,self._ctx)

                self.state = 655
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.COMMA:
                    self.state = 653
                    self.match(JavaParser.COMMA)
                    self.state = 654
                    self.last_formal_parameter()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 657
                self.last_formal_parameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formal_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def receiver_parameter(self):
            return self.getTypedRuleContext(JavaParser.Receiver_parameterContext,0)


        def COMMA(self):
            return self.getToken(JavaParser.COMMA, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(JavaParser.Formal_parameter_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_formal_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormal_parameters" ):
                listener.enterFormal_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormal_parameters" ):
                listener.exitFormal_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormal_parameters" ):
                return visitor.visitFormal_parameters(self)
            else:
                return visitor.visitChildren(self)




    def formal_parameters(self):

        localctx = JavaParser.Formal_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_formal_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 660
            self.match(JavaParser.PAREN_S)
            self.state = 672
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.state = 662
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                    self.state = 661
                    self.receiver_parameter()


                pass

            elif la_ == 2:
                self.state = 664
                self.receiver_parameter()
                self.state = 667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.COMMA:
                    self.state = 665
                    self.match(JavaParser.COMMA)
                    self.state = 666
                    self.formal_parameter_list()


                pass

            elif la_ == 3:
                self.state = 670
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FINAL - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                    self.state = 669
                    self.formal_parameter_list()


                pass


            self.state = 674
            self.match(JavaParser.PAREN_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formal_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def variable_declarator_id(self):
            return self.getTypedRuleContext(JavaParser.Variable_declarator_idContext,0)


        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_formal_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormal_parameter" ):
                listener.enterFormal_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormal_parameter" ):
                listener.exitFormal_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormal_parameter" ):
                return visitor.visitFormal_parameter(self)
            else:
                return visitor.visitChildren(self)




    def formal_parameter(self):

        localctx = JavaParser.Formal_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_formal_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,67,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 676
                    self.variable_modifier() 
                self.state = 681
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,67,self._ctx)

            self.state = 682
            self.type_type()
            self.state = 683
            self.variable_declarator_id()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FINAL(self):
            return self.getToken(JavaParser.FINAL, 0)

        def annotation(self):
            return self.getTypedRuleContext(JavaParser.AnnotationContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_variable_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_modifier" ):
                listener.enterVariable_modifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_modifier" ):
                listener.exitVariable_modifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_modifier" ):
                return visitor.visitVariable_modifier(self)
            else:
                return visitor.visitChildren(self)




    def variable_modifier(self):

        localctx = JavaParser.Variable_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_variable_modifier)
        try:
            self.state = 687
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.FINAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 685
                self.match(JavaParser.FINAL)
                pass
            elif token in [JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 686
                self.annotation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Method_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_method_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethod_body" ):
                listener.enterMethod_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethod_body" ):
                listener.exitMethod_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethod_body" ):
                return visitor.visitMethod_body(self)
            else:
                return visitor.visitChildren(self)




    def method_body(self):

        localctx = JavaParser.Method_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_method_body)
        try:
            self.state = 691
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.BLOCK_S]:
                self.enterOuterAlt(localctx, 1)
                self.state = 689
                self.block()
                pass
            elif token in [JavaParser.SEMI]:
                self.enterOuterAlt(localctx, 2)
                self.state = 690
                self.match(JavaParser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Generic_constructor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_parameters(self):
            return self.getTypedRuleContext(JavaParser.Type_parametersContext,0)


        def constructor_declaration(self):
            return self.getTypedRuleContext(JavaParser.Constructor_declarationContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_generic_constructor_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneric_constructor_declaration" ):
                listener.enterGeneric_constructor_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneric_constructor_declaration" ):
                listener.exitGeneric_constructor_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneric_constructor_declaration" ):
                return visitor.visitGeneric_constructor_declaration(self)
            else:
                return visitor.visitChildren(self)




    def generic_constructor_declaration(self):

        localctx = JavaParser.Generic_constructor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_generic_constructor_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 693
            self.type_parameters()
            self.state = 694
            self.constructor_declaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constructor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.constructorBody = None # BlockContext

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def formal_parameters(self):
            return self.getTypedRuleContext(JavaParser.Formal_parametersContext,0)


        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def THROWS(self):
            return self.getToken(JavaParser.THROWS, 0)

        def qualified_name_list(self):
            return self.getTypedRuleContext(JavaParser.Qualified_name_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_constructor_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructor_declaration" ):
                listener.enterConstructor_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructor_declaration" ):
                listener.exitConstructor_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructor_declaration" ):
                return visitor.visitConstructor_declaration(self)
            else:
                return visitor.visitChildren(self)




    def constructor_declaration(self):

        localctx = JavaParser.Constructor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_constructor_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self.identifier()
            self.state = 697
            self.formal_parameters()
            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.THROWS:
                self.state = 698
                self.match(JavaParser.THROWS)
                self.state = 699
                self.qualified_name_list()


            self.state = 702
            localctx.constructorBody = self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(JavaParser.ENUM, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def IMPLEMENTS(self):
            return self.getToken(JavaParser.IMPLEMENTS, 0)

        def type_list(self):
            return self.getTypedRuleContext(JavaParser.Type_listContext,0)


        def enum_constants(self):
            return self.getTypedRuleContext(JavaParser.Enum_constantsContext,0)


        def COMMA(self):
            return self.getToken(JavaParser.COMMA, 0)

        def enum_body_declarations(self):
            return self.getTypedRuleContext(JavaParser.Enum_body_declarationsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_enum_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_declaration" ):
                listener.enterEnum_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_declaration" ):
                listener.exitEnum_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_declaration" ):
                return visitor.visitEnum_declaration(self)
            else:
                return visitor.visitChildren(self)




    def enum_declaration(self):

        localctx = JavaParser.Enum_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_enum_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 704
            self.match(JavaParser.ENUM)
            self.state = 705
            self.identifier()
            self.state = 708
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.IMPLEMENTS:
                self.state = 706
                self.match(JavaParser.IMPLEMENTS)
                self.state = 707
                self.type_list()


            self.state = 710
            self.match(JavaParser.BLOCK_S)
            self.state = 712
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                self.state = 711
                self.enum_constants()


            self.state = 715
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.COMMA:
                self.state = 714
                self.match(JavaParser.COMMA)


            self.state = 718
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.SEMI:
                self.state = 717
                self.enum_body_declarations()


            self.state = 720
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_constantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enum_constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Enum_constantContext)
            else:
                return self.getTypedRuleContext(JavaParser.Enum_constantContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_enum_constants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_constants" ):
                listener.enterEnum_constants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_constants" ):
                listener.exitEnum_constants(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_constants" ):
                return visitor.visitEnum_constants(self)
            else:
                return visitor.visitChildren(self)




    def enum_constants(self):

        localctx = JavaParser.Enum_constantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_enum_constants)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 722
            self.enum_constant()
            self.state = 727
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,75,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 723
                    self.match(JavaParser.COMMA)
                    self.state = 724
                    self.enum_constant() 
                self.state = 729
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,75,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_constantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def arguments(self):
            return self.getTypedRuleContext(JavaParser.ArgumentsContext,0)


        def class_body(self):
            return self.getTypedRuleContext(JavaParser.Class_bodyContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_enum_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_constant" ):
                listener.enterEnum_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_constant" ):
                listener.exitEnum_constant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_constant" ):
                return visitor.visitEnum_constant(self)
            else:
                return visitor.visitChildren(self)




    def enum_constant(self):

        localctx = JavaParser.Enum_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_enum_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 733
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,76,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 730
                    self.annotation() 
                self.state = 735
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,76,self._ctx)

            self.state = 736
            self.identifier()
            self.state = 738
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.PAREN_S:
                self.state = 737
                self.arguments()


            self.state = 741
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.BLOCK_S:
                self.state = 740
                self.class_body()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_body_declarationsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def class_body_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Class_body_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Class_body_declarationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_enum_body_declarations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnum_body_declarations" ):
                listener.enterEnum_body_declarations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnum_body_declarations" ):
                listener.exitEnum_body_declarations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnum_body_declarations" ):
                return visitor.visitEnum_body_declarations(self)
            else:
                return visitor.visitChildren(self)




    def enum_body_declarations(self):

        localctx = JavaParser.Enum_body_declarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_enum_body_declarations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 743
            self.match(JavaParser.SEMI)
            self.state = 747
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.ENUM - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NATIVE - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.TRANSIENT - 1)) | (1 << (JavaParser.VOID - 1)) | (1 << (JavaParser.VOLATILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.BLOCK_S - 65)) | (1 << (JavaParser.LT - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                self.state = 744
                self.class_body_declaration()
                self.state = 749
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Record_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECORD(self):
            return self.getToken(JavaParser.RECORD, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def record_header(self):
            return self.getTypedRuleContext(JavaParser.Record_headerContext,0)


        def record_body(self):
            return self.getTypedRuleContext(JavaParser.Record_bodyContext,0)


        def type_parameters(self):
            return self.getTypedRuleContext(JavaParser.Type_parametersContext,0)


        def IMPLEMENTS(self):
            return self.getToken(JavaParser.IMPLEMENTS, 0)

        def type_list(self):
            return self.getTypedRuleContext(JavaParser.Type_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_record_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecord_declaration" ):
                listener.enterRecord_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecord_declaration" ):
                listener.exitRecord_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecord_declaration" ):
                return visitor.visitRecord_declaration(self)
            else:
                return visitor.visitChildren(self)




    def record_declaration(self):

        localctx = JavaParser.Record_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_record_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 750
            self.match(JavaParser.RECORD)
            self.state = 751
            self.identifier()
            self.state = 753
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.LT:
                self.state = 752
                self.type_parameters()


            self.state = 755
            self.record_header()
            self.state = 758
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.IMPLEMENTS:
                self.state = 756
                self.match(JavaParser.IMPLEMENTS)
                self.state = 757
                self.type_list()


            self.state = 760
            self.record_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Record_headerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def record_component_list(self):
            return self.getTypedRuleContext(JavaParser.Record_component_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_record_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecord_header" ):
                listener.enterRecord_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecord_header" ):
                listener.exitRecord_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecord_header" ):
                return visitor.visitRecord_header(self)
            else:
                return visitor.visitChildren(self)




    def record_header(self):

        localctx = JavaParser.Record_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_record_header)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 762
            self.match(JavaParser.PAREN_S)
            self.state = 764
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                self.state = 763
                self.record_component_list()


            self.state = 766
            self.match(JavaParser.PAREN_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Record_component_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def record_component(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Record_componentContext)
            else:
                return self.getTypedRuleContext(JavaParser.Record_componentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_record_component_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecord_component_list" ):
                listener.enterRecord_component_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecord_component_list" ):
                listener.exitRecord_component_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecord_component_list" ):
                return visitor.visitRecord_component_list(self)
            else:
                return visitor.visitChildren(self)




    def record_component_list(self):

        localctx = JavaParser.Record_component_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_record_component_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 768
            self.record_component()
            self.state = 773
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 769
                self.match(JavaParser.COMMA)
                self.state = 770
                self.record_component()
                self.state = 775
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Record_componentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_record_component

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecord_component" ):
                listener.enterRecord_component(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecord_component" ):
                listener.exitRecord_component(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecord_component" ):
                return visitor.visitRecord_component(self)
            else:
                return visitor.visitChildren(self)




    def record_component(self):

        localctx = JavaParser.Record_componentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_record_component)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 776
            self.type_type()
            self.state = 777
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Record_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def class_body_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Class_body_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Class_body_declarationContext,i)


        def compact_constructor_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Compact_constructor_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Compact_constructor_declarationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_record_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRecord_body" ):
                listener.enterRecord_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRecord_body" ):
                listener.exitRecord_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecord_body" ):
                return visitor.visitRecord_body(self)
            else:
                return visitor.visitChildren(self)




    def record_body(self):

        localctx = JavaParser.Record_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_record_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 779
            self.match(JavaParser.BLOCK_S)
            self.state = 784
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.ENUM - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NATIVE - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.TRANSIENT - 1)) | (1 << (JavaParser.VOID - 1)) | (1 << (JavaParser.VOLATILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.BLOCK_S - 65)) | (1 << (JavaParser.LT - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                self.state = 782
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                if la_ == 1:
                    self.state = 780
                    self.class_body_declaration()
                    pass

                elif la_ == 2:
                    self.state = 781
                    self.compact_constructor_declaration()
                    pass


                self.state = 786
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 787
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compact_constructor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.constructorBody = None # BlockContext

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.ModifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_compact_constructor_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompact_constructor_declaration" ):
                listener.enterCompact_constructor_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompact_constructor_declaration" ):
                listener.exitCompact_constructor_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompact_constructor_declaration" ):
                return visitor.visitCompact_constructor_declaration(self)
            else:
                return visitor.visitChildren(self)




    def compact_constructor_declaration(self):

        localctx = JavaParser.Compact_constructor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_compact_constructor_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 789
                    self.modifier() 
                self.state = 794
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

            self.state = 795
            self.identifier()
            self.state = 796
            localctx.constructorBody = self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERFACE(self):
            return self.getToken(JavaParser.INTERFACE, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def interface_body(self):
            return self.getTypedRuleContext(JavaParser.Interface_bodyContext,0)


        def type_parameters(self):
            return self.getTypedRuleContext(JavaParser.Type_parametersContext,0)


        def EXTENDS(self):
            return self.getToken(JavaParser.EXTENDS, 0)

        def type_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_listContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_listContext,i)


        def PERMITS(self):
            return self.getToken(JavaParser.PERMITS, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_interface_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_declaration" ):
                listener.enterInterface_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_declaration" ):
                listener.exitInterface_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_declaration" ):
                return visitor.visitInterface_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_declaration(self):

        localctx = JavaParser.Interface_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_interface_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 798
            self.match(JavaParser.INTERFACE)
            self.state = 799
            self.identifier()
            self.state = 801
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.LT:
                self.state = 800
                self.type_parameters()


            self.state = 805
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.EXTENDS:
                self.state = 803
                self.match(JavaParser.EXTENDS)
                self.state = 804
                self.type_list()


            self.state = 809
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.PERMITS:
                self.state = 807
                self.match(JavaParser.PERMITS)
                self.state = 808
                self.type_list()


            self.state = 811
            self.interface_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def interface_body_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Interface_body_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Interface_body_declarationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_interface_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_body" ):
                listener.enterInterface_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_body" ):
                listener.exitInterface_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_body" ):
                return visitor.visitInterface_body(self)
            else:
                return visitor.visitChildren(self)




    def interface_body(self):

        localctx = JavaParser.Interface_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_interface_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 813
            self.match(JavaParser.BLOCK_S)
            self.state = 817
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.DEFAULT - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.ENUM - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NATIVE - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.TRANSIENT - 1)) | (1 << (JavaParser.VOID - 1)) | (1 << (JavaParser.VOLATILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.LT - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                self.state = 814
                self.interface_body_declaration()
                self.state = 819
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 820
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_type_or_voidContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def VOID(self):
            return self.getToken(JavaParser.VOID, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_type_type_or_void

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_type_or_void" ):
                listener.enterType_type_or_void(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_type_or_void" ):
                listener.exitType_type_or_void(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_type_or_void" ):
                return visitor.visitType_type_or_void(self)
            else:
                return visitor.visitChildren(self)




    def type_type_or_void(self):

        localctx = JavaParser.Type_type_or_voidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_type_type_or_void)
        try:
            self.state = 824
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.DOUBLE, JavaParser.FLOAT, JavaParser.INT, JavaParser.LONG, JavaParser.SHORT, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 822
                self.type_type()
                pass
            elif token in [JavaParser.VOID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 823
                self.match(JavaParser.VOID)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Generic_method_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_parameters(self):
            return self.getTypedRuleContext(JavaParser.Type_parametersContext,0)


        def method_declaration(self):
            return self.getTypedRuleContext(JavaParser.Method_declarationContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_generic_method_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneric_method_declaration" ):
                listener.enterGeneric_method_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneric_method_declaration" ):
                listener.exitGeneric_method_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneric_method_declaration" ):
                return visitor.visitGeneric_method_declaration(self)
            else:
                return visitor.visitChildren(self)




    def generic_method_declaration(self):

        localctx = JavaParser.Generic_method_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_generic_method_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 826
            self.type_parameters()
            self.state = 827
            self.method_declaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_body_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_member_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_member_declarationContext,0)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.ModifierContext,i)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_interface_body_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_body_declaration" ):
                listener.enterInterface_body_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_body_declaration" ):
                listener.exitInterface_body_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_body_declaration" ):
                return visitor.visitInterface_body_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_body_declaration(self):

        localctx = JavaParser.Interface_body_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_interface_body_declaration)
        try:
            self.state = 837
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.ABSTRACT, JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.CLASS, JavaParser.DEFAULT, JavaParser.DOUBLE, JavaParser.ENUM, JavaParser.FINAL, JavaParser.FLOAT, JavaParser.INT, JavaParser.INTERFACE, JavaParser.LONG, JavaParser.NATIVE, JavaParser.PRIVATE, JavaParser.PROTECTED, JavaParser.PUBLIC, JavaParser.SHORT, JavaParser.STATIC, JavaParser.STRICTFP, JavaParser.SYNCHRONIZED, JavaParser.TRANSIENT, JavaParser.VOID, JavaParser.VOLATILE, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.NON_SEALED, JavaParser.LT, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 832
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 829
                        self.modifier() 
                    self.state = 834
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

                self.state = 835
                self.interface_member_declaration()
                pass
            elif token in [JavaParser.SEMI]:
                self.enterOuterAlt(localctx, 2)
                self.state = 836
                self.match(JavaParser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def const_declaration(self):
            return self.getTypedRuleContext(JavaParser.Const_declarationContext,0)


        def interface_method_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_method_declarationContext,0)


        def generic_interface_method_declaration(self):
            return self.getTypedRuleContext(JavaParser.Generic_interface_method_declarationContext,0)


        def interface_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_declarationContext,0)


        def annotation_type_declaration(self):
            return self.getTypedRuleContext(JavaParser.Annotation_type_declarationContext,0)


        def class_declaration(self):
            return self.getTypedRuleContext(JavaParser.Class_declarationContext,0)


        def enum_declaration(self):
            return self.getTypedRuleContext(JavaParser.Enum_declarationContext,0)


        def record_declaration(self):
            return self.getTypedRuleContext(JavaParser.Record_declarationContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_interface_member_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_member_declaration" ):
                listener.enterInterface_member_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_member_declaration" ):
                listener.exitInterface_member_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_member_declaration" ):
                return visitor.visitInterface_member_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_member_declaration(self):

        localctx = JavaParser.Interface_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_interface_member_declaration)
        try:
            self.state = 847
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 839
                self.const_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 840
                self.interface_method_declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 841
                self.generic_interface_method_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 842
                self.interface_declaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 843
                self.annotation_type_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 844
                self.class_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 845
                self.enum_declaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 846
                self.record_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Const_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def constant_declarator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Constant_declaratorContext)
            else:
                return self.getTypedRuleContext(JavaParser.Constant_declaratorContext,i)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_const_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConst_declaration" ):
                listener.enterConst_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConst_declaration" ):
                listener.exitConst_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConst_declaration" ):
                return visitor.visitConst_declaration(self)
            else:
                return visitor.visitChildren(self)




    def const_declaration(self):

        localctx = JavaParser.Const_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_const_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 849
            self.type_type()
            self.state = 850
            self.constant_declarator()
            self.state = 855
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 851
                self.match(JavaParser.COMMA)
                self.state = 852
                self.constant_declarator()
                self.state = 857
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 858
            self.match(JavaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(JavaParser.ASSIGN, 0)

        def variable_initializer(self):
            return self.getTypedRuleContext(JavaParser.Variable_initializerContext,0)


        def ARRAY_S(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_S)
            else:
                return self.getToken(JavaParser.ARRAY_S, i)

        def ARRAY_E(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_E)
            else:
                return self.getToken(JavaParser.ARRAY_E, i)

        def getRuleIndex(self):
            return JavaParser.RULE_constant_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant_declarator" ):
                listener.enterConstant_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant_declarator" ):
                listener.exitConstant_declarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant_declarator" ):
                return visitor.visitConstant_declarator(self)
            else:
                return visitor.visitChildren(self)




    def constant_declarator(self):

        localctx = JavaParser.Constant_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_constant_declarator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 860
            self.identifier()
            self.state = 865
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.ARRAY_S:
                self.state = 861
                self.match(JavaParser.ARRAY_S)
                self.state = 862
                self.match(JavaParser.ARRAY_E)
                self.state = 867
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 868
            self.match(JavaParser.ASSIGN)
            self.state = 869
            self.variable_initializer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_method_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interface_common_body_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_common_body_declarationContext,0)


        def interface_method_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Interface_method_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Interface_method_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_interface_method_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_method_declaration" ):
                listener.enterInterface_method_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_method_declaration" ):
                listener.exitInterface_method_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_method_declaration" ):
                return visitor.visitInterface_method_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_method_declaration(self):

        localctx = JavaParser.Interface_method_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_interface_method_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,97,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 871
                    self.interface_method_modifier() 
                self.state = 876
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,97,self._ctx)

            self.state = 877
            self.interface_common_body_declaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_method_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(JavaParser.AnnotationContext,0)


        def PUBLIC(self):
            return self.getToken(JavaParser.PUBLIC, 0)

        def ABSTRACT(self):
            return self.getToken(JavaParser.ABSTRACT, 0)

        def DEFAULT(self):
            return self.getToken(JavaParser.DEFAULT, 0)

        def STATIC(self):
            return self.getToken(JavaParser.STATIC, 0)

        def STRICTFP(self):
            return self.getToken(JavaParser.STRICTFP, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_interface_method_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_method_modifier" ):
                listener.enterInterface_method_modifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_method_modifier" ):
                listener.exitInterface_method_modifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_method_modifier" ):
                return visitor.visitInterface_method_modifier(self)
            else:
                return visitor.visitChildren(self)




    def interface_method_modifier(self):

        localctx = JavaParser.Interface_method_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_interface_method_modifier)
        try:
            self.state = 885
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 879
                self.annotation()
                pass
            elif token in [JavaParser.PUBLIC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 880
                self.match(JavaParser.PUBLIC)
                pass
            elif token in [JavaParser.ABSTRACT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 881
                self.match(JavaParser.ABSTRACT)
                pass
            elif token in [JavaParser.DEFAULT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 882
                self.match(JavaParser.DEFAULT)
                pass
            elif token in [JavaParser.STATIC]:
                self.enterOuterAlt(localctx, 5)
                self.state = 883
                self.match(JavaParser.STATIC)
                pass
            elif token in [JavaParser.STRICTFP]:
                self.enterOuterAlt(localctx, 6)
                self.state = 884
                self.match(JavaParser.STRICTFP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Generic_interface_method_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_parameters(self):
            return self.getTypedRuleContext(JavaParser.Type_parametersContext,0)


        def interface_common_body_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_common_body_declarationContext,0)


        def interface_method_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Interface_method_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Interface_method_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_generic_interface_method_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneric_interface_method_declaration" ):
                listener.enterGeneric_interface_method_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneric_interface_method_declaration" ):
                listener.exitGeneric_interface_method_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGeneric_interface_method_declaration" ):
                return visitor.visitGeneric_interface_method_declaration(self)
            else:
                return visitor.visitChildren(self)




    def generic_interface_method_declaration(self):

        localctx = JavaParser.Generic_interface_method_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_generic_interface_method_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 890
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.DEFAULT - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                self.state = 887
                self.interface_method_modifier()
                self.state = 892
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 893
            self.type_parameters()
            self.state = 894
            self.interface_common_body_declaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_common_body_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type_or_void(self):
            return self.getTypedRuleContext(JavaParser.Type_type_or_voidContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def formal_parameters(self):
            return self.getTypedRuleContext(JavaParser.Formal_parametersContext,0)


        def method_body(self):
            return self.getTypedRuleContext(JavaParser.Method_bodyContext,0)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def ARRAY_S(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_S)
            else:
                return self.getToken(JavaParser.ARRAY_S, i)

        def ARRAY_E(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_E)
            else:
                return self.getToken(JavaParser.ARRAY_E, i)

        def THROWS(self):
            return self.getToken(JavaParser.THROWS, 0)

        def qualified_name_list(self):
            return self.getTypedRuleContext(JavaParser.Qualified_name_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_interface_common_body_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterface_common_body_declaration" ):
                listener.enterInterface_common_body_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterface_common_body_declaration" ):
                listener.exitInterface_common_body_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterface_common_body_declaration" ):
                return visitor.visitInterface_common_body_declaration(self)
            else:
                return visitor.visitChildren(self)




    def interface_common_body_declaration(self):

        localctx = JavaParser.Interface_common_body_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_interface_common_body_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 899
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,100,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 896
                    self.annotation() 
                self.state = 901
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,100,self._ctx)

            self.state = 902
            self.type_type_or_void()
            self.state = 903
            self.identifier()
            self.state = 904
            self.formal_parameters()
            self.state = 909
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.ARRAY_S:
                self.state = 905
                self.match(JavaParser.ARRAY_S)
                self.state = 906
                self.match(JavaParser.ARRAY_E)
                self.state = 911
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 914
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.THROWS:
                self.state = 912
                self.match(JavaParser.THROWS)
                self.state = 913
                self.qualified_name_list()


            self.state = 916
            self.method_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Default_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT(self):
            return self.getToken(JavaParser.DEFAULT, 0)

        def element_value(self):
            return self.getTypedRuleContext(JavaParser.Element_valueContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_default_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault_value" ):
                listener.enterDefault_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault_value" ):
                listener.exitDefault_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_value" ):
                return visitor.visitDefault_value(self)
            else:
                return visitor.visitChildren(self)




    def default_value(self):

        localctx = JavaParser.Default_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_default_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 918
            self.match(JavaParser.DEFAULT)
            self.state = 919
            self.element_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Alt_annotation_qualified_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(JavaParser.AT, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.IdentifierContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.DOT)
            else:
                return self.getToken(JavaParser.DOT, i)

        def getRuleIndex(self):
            return JavaParser.RULE_alt_annotation_qualified_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlt_annotation_qualified_name" ):
                listener.enterAlt_annotation_qualified_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlt_annotation_qualified_name" ):
                listener.exitAlt_annotation_qualified_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlt_annotation_qualified_name" ):
                return visitor.visitAlt_annotation_qualified_name(self)
            else:
                return visitor.visitChildren(self)




    def alt_annotation_qualified_name(self):

        localctx = JavaParser.Alt_annotation_qualified_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_alt_annotation_qualified_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 926
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.IDENTIFIER:
                self.state = 921
                self.identifier()
                self.state = 922
                self.match(JavaParser.DOT)
                self.state = 928
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 929
            self.match(JavaParser.AT)
            self.state = 930
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnnotationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(JavaParser.AT, 0)

        def qualified_name(self):
            return self.getTypedRuleContext(JavaParser.Qualified_nameContext,0)


        def alt_annotation_qualified_name(self):
            return self.getTypedRuleContext(JavaParser.Alt_annotation_qualified_nameContext,0)


        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def element_value_pairs(self):
            return self.getTypedRuleContext(JavaParser.Element_value_pairsContext,0)


        def element_value(self):
            return self.getTypedRuleContext(JavaParser.Element_valueContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_annotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation" ):
                listener.enterAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation" ):
                listener.exitAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation" ):
                return visitor.visitAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def annotation(self):

        localctx = JavaParser.AnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_annotation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 935
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.state = 932
                self.match(JavaParser.AT)
                self.state = 933
                self.qualified_name()
                pass

            elif la_ == 2:
                self.state = 934
                self.alt_annotation_qualified_name()
                pass


            self.state = 943
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.PAREN_S:
                self.state = 937
                self.match(JavaParser.PAREN_S)
                self.state = 940
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
                if la_ == 1:
                    self.state = 938
                    self.element_value_pairs()

                elif la_ == 2:
                    self.state = 939
                    self.element_value()


                self.state = 942
                self.match(JavaParser.PAREN_E)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Element_value_pairsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def element_value_pair(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Element_value_pairContext)
            else:
                return self.getTypedRuleContext(JavaParser.Element_value_pairContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_element_value_pairs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_value_pairs" ):
                listener.enterElement_value_pairs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_value_pairs" ):
                listener.exitElement_value_pairs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_value_pairs" ):
                return visitor.visitElement_value_pairs(self)
            else:
                return visitor.visitChildren(self)




    def element_value_pairs(self):

        localctx = JavaParser.Element_value_pairsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_element_value_pairs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 945
            self.element_value_pair()
            self.state = 950
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 946
                self.match(JavaParser.COMMA)
                self.state = 947
                self.element_value_pair()
                self.state = 952
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Element_value_pairContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(JavaParser.ASSIGN, 0)

        def element_value(self):
            return self.getTypedRuleContext(JavaParser.Element_valueContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_element_value_pair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_value_pair" ):
                listener.enterElement_value_pair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_value_pair" ):
                listener.exitElement_value_pair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_value_pair" ):
                return visitor.visitElement_value_pair(self)
            else:
                return visitor.visitChildren(self)




    def element_value_pair(self):

        localctx = JavaParser.Element_value_pairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_element_value_pair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 953
            self.identifier()
            self.state = 954
            self.match(JavaParser.ASSIGN)
            self.state = 955
            self.element_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Element_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def annotation(self):
            return self.getTypedRuleContext(JavaParser.AnnotationContext,0)


        def element_value_array_initializer(self):
            return self.getTypedRuleContext(JavaParser.Element_value_array_initializerContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_element_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_value" ):
                listener.enterElement_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_value" ):
                listener.exitElement_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_value" ):
                return visitor.visitElement_value(self)
            else:
                return visitor.visitChildren(self)




    def element_value(self):

        localctx = JavaParser.Element_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_element_value)
        try:
            self.state = 960
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 957
                self.expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 958
                self.annotation()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 959
                self.element_value_array_initializer()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Element_value_array_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def element_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Element_valueContext)
            else:
                return self.getTypedRuleContext(JavaParser.Element_valueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_element_value_array_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement_value_array_initializer" ):
                listener.enterElement_value_array_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement_value_array_initializer" ):
                listener.exitElement_value_array_initializer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement_value_array_initializer" ):
                return visitor.visitElement_value_array_initializer(self)
            else:
                return visitor.visitChildren(self)




    def element_value_array_initializer(self):

        localctx = JavaParser.Element_value_array_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_element_value_array_initializer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 962
            self.match(JavaParser.BLOCK_S)
            self.state = 971
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.BLOCK_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                self.state = 963
                self.element_value()
                self.state = 968
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,109,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 964
                        self.match(JavaParser.COMMA)
                        self.state = 965
                        self.element_value() 
                    self.state = 970
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,109,self._ctx)



            self.state = 974
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.COMMA:
                self.state = 973
                self.match(JavaParser.COMMA)


            self.state = 976
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Annotation_type_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(JavaParser.AT, 0)

        def INTERFACE(self):
            return self.getToken(JavaParser.INTERFACE, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def annotation_type_body(self):
            return self.getTypedRuleContext(JavaParser.Annotation_type_bodyContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_annotation_type_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation_type_declaration" ):
                listener.enterAnnotation_type_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation_type_declaration" ):
                listener.exitAnnotation_type_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation_type_declaration" ):
                return visitor.visitAnnotation_type_declaration(self)
            else:
                return visitor.visitChildren(self)




    def annotation_type_declaration(self):

        localctx = JavaParser.Annotation_type_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_annotation_type_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 978
            self.match(JavaParser.AT)
            self.state = 979
            self.match(JavaParser.INTERFACE)
            self.state = 980
            self.identifier()
            self.state = 981
            self.annotation_type_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Annotation_type_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def annotation_type_element_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Annotation_type_element_declarationContext)
            else:
                return self.getTypedRuleContext(JavaParser.Annotation_type_element_declarationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_annotation_type_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation_type_body" ):
                listener.enterAnnotation_type_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation_type_body" ):
                listener.exitAnnotation_type_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation_type_body" ):
                return visitor.visitAnnotation_type_body(self)
            else:
                return visitor.visitChildren(self)




    def annotation_type_body(self):

        localctx = JavaParser.Annotation_type_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_annotation_type_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 983
            self.match(JavaParser.BLOCK_S)
            self.state = 987
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.ENUM - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NATIVE - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.TRANSIENT - 1)) | (1 << (JavaParser.VOLATILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                self.state = 984
                self.annotation_type_element_declaration()
                self.state = 989
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 990
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Annotation_type_element_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation_type_element_rest(self):
            return self.getTypedRuleContext(JavaParser.Annotation_type_element_restContext,0)


        def modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ModifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.ModifierContext,i)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_annotation_type_element_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation_type_element_declaration" ):
                listener.enterAnnotation_type_element_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation_type_element_declaration" ):
                listener.exitAnnotation_type_element_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation_type_element_declaration" ):
                return visitor.visitAnnotation_type_element_declaration(self)
            else:
                return visitor.visitChildren(self)




    def annotation_type_element_declaration(self):

        localctx = JavaParser.Annotation_type_element_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_annotation_type_element_declaration)
        try:
            self.state = 1000
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.ABSTRACT, JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.CLASS, JavaParser.DOUBLE, JavaParser.ENUM, JavaParser.FINAL, JavaParser.FLOAT, JavaParser.INT, JavaParser.INTERFACE, JavaParser.LONG, JavaParser.NATIVE, JavaParser.PRIVATE, JavaParser.PROTECTED, JavaParser.PUBLIC, JavaParser.SHORT, JavaParser.STATIC, JavaParser.STRICTFP, JavaParser.SYNCHRONIZED, JavaParser.TRANSIENT, JavaParser.VOLATILE, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.NON_SEALED, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 995
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,113,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 992
                        self.modifier() 
                    self.state = 997
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

                self.state = 998
                self.annotation_type_element_rest()
                pass
            elif token in [JavaParser.SEMI]:
                self.enterOuterAlt(localctx, 2)
                self.state = 999
                self.match(JavaParser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Annotation_type_element_restContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def annotation_method_or_constant_rest(self):
            return self.getTypedRuleContext(JavaParser.Annotation_method_or_constant_restContext,0)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def class_declaration(self):
            return self.getTypedRuleContext(JavaParser.Class_declarationContext,0)


        def interface_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_declarationContext,0)


        def enum_declaration(self):
            return self.getTypedRuleContext(JavaParser.Enum_declarationContext,0)


        def annotation_type_declaration(self):
            return self.getTypedRuleContext(JavaParser.Annotation_type_declarationContext,0)


        def record_declaration(self):
            return self.getTypedRuleContext(JavaParser.Record_declarationContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_annotation_type_element_rest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation_type_element_rest" ):
                listener.enterAnnotation_type_element_rest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation_type_element_rest" ):
                listener.exitAnnotation_type_element_rest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation_type_element_rest" ):
                return visitor.visitAnnotation_type_element_rest(self)
            else:
                return visitor.visitChildren(self)




    def annotation_type_element_rest(self):

        localctx = JavaParser.Annotation_type_element_restContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_annotation_type_element_rest)
        try:
            self.state = 1026
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1002
                self.type_type()
                self.state = 1003
                self.annotation_method_or_constant_rest()
                self.state = 1004
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1006
                self.class_declaration()
                self.state = 1008
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
                if la_ == 1:
                    self.state = 1007
                    self.match(JavaParser.SEMI)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1010
                self.interface_declaration()
                self.state = 1012
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                if la_ == 1:
                    self.state = 1011
                    self.match(JavaParser.SEMI)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1014
                self.enum_declaration()
                self.state = 1016
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
                if la_ == 1:
                    self.state = 1015
                    self.match(JavaParser.SEMI)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1018
                self.annotation_type_declaration()
                self.state = 1020
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 1019
                    self.match(JavaParser.SEMI)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1022
                self.record_declaration()
                self.state = 1024
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
                if la_ == 1:
                    self.state = 1023
                    self.match(JavaParser.SEMI)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Annotation_method_or_constant_restContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation_method_rest(self):
            return self.getTypedRuleContext(JavaParser.Annotation_method_restContext,0)


        def annotation_constant_rest(self):
            return self.getTypedRuleContext(JavaParser.Annotation_constant_restContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_annotation_method_or_constant_rest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation_method_or_constant_rest" ):
                listener.enterAnnotation_method_or_constant_rest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation_method_or_constant_rest" ):
                listener.exitAnnotation_method_or_constant_rest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation_method_or_constant_rest" ):
                return visitor.visitAnnotation_method_or_constant_rest(self)
            else:
                return visitor.visitChildren(self)




    def annotation_method_or_constant_rest(self):

        localctx = JavaParser.Annotation_method_or_constant_restContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_annotation_method_or_constant_rest)
        try:
            self.state = 1030
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1028
                self.annotation_method_rest()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1029
                self.annotation_constant_rest()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Annotation_method_restContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def default_value(self):
            return self.getTypedRuleContext(JavaParser.Default_valueContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_annotation_method_rest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation_method_rest" ):
                listener.enterAnnotation_method_rest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation_method_rest" ):
                listener.exitAnnotation_method_rest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation_method_rest" ):
                return visitor.visitAnnotation_method_rest(self)
            else:
                return visitor.visitChildren(self)




    def annotation_method_rest(self):

        localctx = JavaParser.Annotation_method_restContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_annotation_method_rest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1032
            self.identifier()
            self.state = 1033
            self.match(JavaParser.PAREN_S)
            self.state = 1034
            self.match(JavaParser.PAREN_E)
            self.state = 1036
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.DEFAULT:
                self.state = 1035
                self.default_value()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Annotation_constant_restContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_declarators(self):
            return self.getTypedRuleContext(JavaParser.Variable_declaratorsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_annotation_constant_rest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotation_constant_rest" ):
                listener.enterAnnotation_constant_rest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotation_constant_rest" ):
                listener.exitAnnotation_constant_rest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotation_constant_rest" ):
                return visitor.visitAnnotation_constant_rest(self)
            else:
                return visitor.visitChildren(self)




    def annotation_constant_rest(self):

        localctx = JavaParser.Annotation_constant_restContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_annotation_constant_rest)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1038
            self.variable_declarators()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def variable_initializer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_initializerContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_initializerContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_array_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_initializer" ):
                listener.enterArray_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_initializer" ):
                listener.exitArray_initializer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_initializer" ):
                return visitor.visitArray_initializer(self)
            else:
                return visitor.visitChildren(self)




    def array_initializer(self):

        localctx = JavaParser.Array_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_array_initializer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1040
            self.match(JavaParser.BLOCK_S)
            self.state = 1052
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.BLOCK_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                self.state = 1041
                self.variable_initializer()
                self.state = 1046
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,123,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1042
                        self.match(JavaParser.COMMA)
                        self.state = 1043
                        self.variable_initializer() 
                    self.state = 1048
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,123,self._ctx)

                self.state = 1050
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.COMMA:
                    self.state = 1049
                    self.match(JavaParser.COMMA)




            self.state = 1054
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def block_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Block_statementContext)
            else:
                return self.getTypedRuleContext(JavaParser.Block_statementContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = JavaParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1056
            self.match(JavaParser.BLOCK_S)
            self.state = 1060
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.ASSERT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BREAK - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.CONTINUE - 1)) | (1 << (JavaParser.DO - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.FOR - 1)) | (1 << (JavaParser.IF - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NEW - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.RETURN - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SUPER - 1)) | (1 << (JavaParser.SWITCH - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.THIS - 1)) | (1 << (JavaParser.THROW - 1)) | (1 << (JavaParser.TRY - 1)) | (1 << (JavaParser.VOID - 1)) | (1 << (JavaParser.WHILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.PAREN_S - 65)) | (1 << (JavaParser.BLOCK_S - 65)) | (1 << (JavaParser.DECIMAL_LITERAL - 65)) | (1 << (JavaParser.HEX_LITERAL - 65)) | (1 << (JavaParser.OCT_LITERAL - 65)) | (1 << (JavaParser.BINARY_LITERAL - 65)) | (1 << (JavaParser.FLOAT_LITERAL - 65)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 65)) | (1 << (JavaParser.BOOL_LITERAL - 65)) | (1 << (JavaParser.CHAR_LITERAL - 65)) | (1 << (JavaParser.STRING_LITERAL - 65)) | (1 << (JavaParser.TEXT_BLOCK - 65)) | (1 << (JavaParser.NULL_LITERAL - 65)) | (1 << (JavaParser.LT - 65)) | (1 << (JavaParser.LOG_NOT - 65)) | (1 << (JavaParser.TILDE - 65)) | (1 << (JavaParser.UNN_INC - 65)) | (1 << (JavaParser.UNN_DEC - 65)) | (1 << (JavaParser.ADD - 65)) | (1 << (JavaParser.SUB - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                self.state = 1057
                self.block_statement()
                self.state = 1062
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1063
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Block_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def local_variable_declaration(self):
            return self.getTypedRuleContext(JavaParser.Local_variable_declarationContext,0)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def local_type_declaration(self):
            return self.getTypedRuleContext(JavaParser.Local_type_declarationContext,0)


        def statement(self):
            return self.getTypedRuleContext(JavaParser.StatementContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_block_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock_statement" ):
                listener.enterBlock_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock_statement" ):
                listener.exitBlock_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock_statement" ):
                return visitor.visitBlock_statement(self)
            else:
                return visitor.visitChildren(self)




    def block_statement(self):

        localctx = JavaParser.Block_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_block_statement)
        try:
            self.state = 1070
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1065
                self.local_variable_declaration()
                self.state = 1066
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1068
                self.local_type_declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1069
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_variable_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(JavaParser.VAR, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def ASSIGN(self):
            return self.getToken(JavaParser.ASSIGN, 0)

        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def variable_declarators(self):
            return self.getTypedRuleContext(JavaParser.Variable_declaratorsContext,0)


        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_local_variable_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocal_variable_declaration" ):
                listener.enterLocal_variable_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocal_variable_declaration" ):
                listener.exitLocal_variable_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocal_variable_declaration" ):
                return visitor.visitLocal_variable_declaration(self)
            else:
                return visitor.visitChildren(self)




    def local_variable_declaration(self):

        localctx = JavaParser.Local_variable_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_local_variable_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1075
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,128,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1072
                    self.variable_modifier() 
                self.state = 1077
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,128,self._ctx)

            self.state = 1086
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
            if la_ == 1:
                self.state = 1078
                self.match(JavaParser.VAR)
                self.state = 1079
                self.identifier()
                self.state = 1080
                self.match(JavaParser.ASSIGN)
                self.state = 1081
                self.expression(0)
                pass

            elif la_ == 2:
                self.state = 1083
                self.type_type()
                self.state = 1084
                self.variable_declarators()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.blockLabel = None # BlockContext
            self.statementExpression = None # ExpressionContext
            self.identifierLabel = None # IdentifierContext

        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def ASSERT(self):
            return self.getToken(JavaParser.ASSERT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(JavaParser.ExpressionContext,i)


        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def COLON(self):
            return self.getToken(JavaParser.COLON, 0)

        def IF(self):
            return self.getToken(JavaParser.IF, 0)

        def par_expression(self):
            return self.getTypedRuleContext(JavaParser.Par_expressionContext,0)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.StatementContext)
            else:
                return self.getTypedRuleContext(JavaParser.StatementContext,i)


        def ELSE(self):
            return self.getToken(JavaParser.ELSE, 0)

        def FOR(self):
            return self.getToken(JavaParser.FOR, 0)

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def for_control(self):
            return self.getTypedRuleContext(JavaParser.For_controlContext,0)


        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def WHILE(self):
            return self.getToken(JavaParser.WHILE, 0)

        def DO(self):
            return self.getToken(JavaParser.DO, 0)

        def TRY(self):
            return self.getToken(JavaParser.TRY, 0)

        def finally_block(self):
            return self.getTypedRuleContext(JavaParser.Finally_blockContext,0)


        def catch_clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Catch_clauseContext)
            else:
                return self.getTypedRuleContext(JavaParser.Catch_clauseContext,i)


        def resource_specification(self):
            return self.getTypedRuleContext(JavaParser.Resource_specificationContext,0)


        def SWITCH(self):
            return self.getToken(JavaParser.SWITCH, 0)

        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def switch_block_statement_group(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Switch_block_statement_groupContext)
            else:
                return self.getTypedRuleContext(JavaParser.Switch_block_statement_groupContext,i)


        def switch_label(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Switch_labelContext)
            else:
                return self.getTypedRuleContext(JavaParser.Switch_labelContext,i)


        def SYNCHRONIZED(self):
            return self.getToken(JavaParser.SYNCHRONIZED, 0)

        def RETURN(self):
            return self.getToken(JavaParser.RETURN, 0)

        def THROW(self):
            return self.getToken(JavaParser.THROW, 0)

        def BREAK(self):
            return self.getToken(JavaParser.BREAK, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def CONTINUE(self):
            return self.getToken(JavaParser.CONTINUE, 0)

        def YIELD(self):
            return self.getToken(JavaParser.YIELD, 0)

        def switch_expression(self):
            return self.getTypedRuleContext(JavaParser.Switch_expressionContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = JavaParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.state = 1201
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,143,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1088
                localctx.blockLabel = self.block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1089
                self.match(JavaParser.ASSERT)
                self.state = 1090
                self.expression(0)
                self.state = 1093
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.COLON:
                    self.state = 1091
                    self.match(JavaParser.COLON)
                    self.state = 1092
                    self.expression(0)


                self.state = 1095
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1097
                self.match(JavaParser.IF)
                self.state = 1098
                self.par_expression()
                self.state = 1099
                self.statement()
                self.state = 1102
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
                if la_ == 1:
                    self.state = 1100
                    self.match(JavaParser.ELSE)
                    self.state = 1101
                    self.statement()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1104
                self.match(JavaParser.FOR)
                self.state = 1105
                self.match(JavaParser.PAREN_S)
                self.state = 1106
                self.for_control()
                self.state = 1107
                self.match(JavaParser.PAREN_E)
                self.state = 1108
                self.statement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1110
                self.match(JavaParser.WHILE)
                self.state = 1111
                self.par_expression()
                self.state = 1112
                self.statement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1114
                self.match(JavaParser.DO)
                self.state = 1115
                self.statement()
                self.state = 1116
                self.match(JavaParser.WHILE)
                self.state = 1117
                self.par_expression()
                self.state = 1118
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1120
                self.match(JavaParser.TRY)
                self.state = 1121
                self.block()
                self.state = 1131
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [JavaParser.CATCH]:
                    self.state = 1123 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 1122
                        self.catch_clause()
                        self.state = 1125 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==JavaParser.CATCH):
                            break

                    self.state = 1128
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==JavaParser.FINALLY:
                        self.state = 1127
                        self.finally_block()


                    pass
                elif token in [JavaParser.FINALLY]:
                    self.state = 1130
                    self.finally_block()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1133
                self.match(JavaParser.TRY)
                self.state = 1134
                self.resource_specification()
                self.state = 1135
                self.block()
                self.state = 1139
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==JavaParser.CATCH:
                    self.state = 1136
                    self.catch_clause()
                    self.state = 1141
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1143
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.FINALLY:
                    self.state = 1142
                    self.finally_block()


                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1145
                self.match(JavaParser.SWITCH)
                self.state = 1146
                self.par_expression()
                self.state = 1147
                self.match(JavaParser.BLOCK_S)
                self.state = 1151
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,137,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1148
                        self.switch_block_statement_group() 
                    self.state = 1153
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,137,self._ctx)

                self.state = 1157
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==JavaParser.CASE or _la==JavaParser.DEFAULT:
                    self.state = 1154
                    self.switch_label()
                    self.state = 1159
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1160
                self.match(JavaParser.BLOCK_E)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1162
                self.match(JavaParser.SYNCHRONIZED)
                self.state = 1163
                self.par_expression()
                self.state = 1164
                self.block()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1166
                self.match(JavaParser.RETURN)
                self.state = 1168
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                    self.state = 1167
                    self.expression(0)


                self.state = 1170
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1171
                self.match(JavaParser.THROW)
                self.state = 1172
                self.expression(0)
                self.state = 1173
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1175
                self.match(JavaParser.BREAK)
                self.state = 1177
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.IDENTIFIER:
                    self.state = 1176
                    self.identifier()


                self.state = 1179
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1180
                self.match(JavaParser.CONTINUE)
                self.state = 1182
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.IDENTIFIER:
                    self.state = 1181
                    self.identifier()


                self.state = 1184
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1185
                self.match(JavaParser.YIELD)
                self.state = 1186
                self.expression(0)
                self.state = 1187
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1189
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1190
                localctx.statementExpression = self.expression(0)
                self.state = 1191
                self.match(JavaParser.SEMI)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1193
                self.switch_expression()
                self.state = 1195
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,142,self._ctx)
                if la_ == 1:
                    self.state = 1194
                    self.match(JavaParser.SEMI)


                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1197
                localctx.identifierLabel = self.identifier()
                self.state = 1198
                self.match(JavaParser.COLON)
                self.state = 1199
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_rule_outcomeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def block_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Block_statementContext)
            else:
                return self.getTypedRuleContext(JavaParser.Block_statementContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_switch_rule_outcome

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitch_rule_outcome" ):
                listener.enterSwitch_rule_outcome(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitch_rule_outcome" ):
                listener.exitSwitch_rule_outcome(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitch_rule_outcome" ):
                return visitor.visitSwitch_rule_outcome(self)
            else:
                return visitor.visitChildren(self)




    def switch_rule_outcome(self):

        localctx = JavaParser.Switch_rule_outcomeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_switch_rule_outcome)
        self._la = 0 # Token type
        try:
            self.state = 1210
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1203
                self.block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.ASSERT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BREAK - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.CONTINUE - 1)) | (1 << (JavaParser.DO - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.FOR - 1)) | (1 << (JavaParser.IF - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NEW - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.RETURN - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SUPER - 1)) | (1 << (JavaParser.SWITCH - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.THIS - 1)) | (1 << (JavaParser.THROW - 1)) | (1 << (JavaParser.TRY - 1)) | (1 << (JavaParser.VOID - 1)) | (1 << (JavaParser.WHILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.PAREN_S - 65)) | (1 << (JavaParser.BLOCK_S - 65)) | (1 << (JavaParser.DECIMAL_LITERAL - 65)) | (1 << (JavaParser.HEX_LITERAL - 65)) | (1 << (JavaParser.OCT_LITERAL - 65)) | (1 << (JavaParser.BINARY_LITERAL - 65)) | (1 << (JavaParser.FLOAT_LITERAL - 65)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 65)) | (1 << (JavaParser.BOOL_LITERAL - 65)) | (1 << (JavaParser.CHAR_LITERAL - 65)) | (1 << (JavaParser.STRING_LITERAL - 65)) | (1 << (JavaParser.TEXT_BLOCK - 65)) | (1 << (JavaParser.NULL_LITERAL - 65)) | (1 << (JavaParser.LT - 65)) | (1 << (JavaParser.LOG_NOT - 65)) | (1 << (JavaParser.TILDE - 65)) | (1 << (JavaParser.UNN_INC - 65)) | (1 << (JavaParser.UNN_DEC - 65)) | (1 << (JavaParser.ADD - 65)) | (1 << (JavaParser.SUB - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0):
                    self.state = 1204
                    self.block_statement()
                    self.state = 1209
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_block_statement_groupContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switch_label(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Switch_labelContext)
            else:
                return self.getTypedRuleContext(JavaParser.Switch_labelContext,i)


        def block_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Block_statementContext)
            else:
                return self.getTypedRuleContext(JavaParser.Block_statementContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_switch_block_statement_group

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitch_block_statement_group" ):
                listener.enterSwitch_block_statement_group(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitch_block_statement_group" ):
                listener.exitSwitch_block_statement_group(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitch_block_statement_group" ):
                return visitor.visitSwitch_block_statement_group(self)
            else:
                return visitor.visitChildren(self)




    def switch_block_statement_group(self):

        localctx = JavaParser.Switch_block_statement_groupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_switch_block_statement_group)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1213 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1212
                self.switch_label()
                self.state = 1215 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JavaParser.CASE or _la==JavaParser.DEFAULT):
                    break

            self.state = 1218 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1217
                self.block_statement()
                self.state = 1220 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 1)) & ~0x3f) == 0 and ((1 << (_la - 1)) & ((1 << (JavaParser.ABSTRACT - 1)) | (1 << (JavaParser.ASSERT - 1)) | (1 << (JavaParser.BOOLEAN - 1)) | (1 << (JavaParser.BREAK - 1)) | (1 << (JavaParser.BYTE - 1)) | (1 << (JavaParser.CHAR - 1)) | (1 << (JavaParser.CLASS - 1)) | (1 << (JavaParser.CONTINUE - 1)) | (1 << (JavaParser.DO - 1)) | (1 << (JavaParser.DOUBLE - 1)) | (1 << (JavaParser.FINAL - 1)) | (1 << (JavaParser.FLOAT - 1)) | (1 << (JavaParser.FOR - 1)) | (1 << (JavaParser.IF - 1)) | (1 << (JavaParser.INT - 1)) | (1 << (JavaParser.INTERFACE - 1)) | (1 << (JavaParser.LONG - 1)) | (1 << (JavaParser.NEW - 1)) | (1 << (JavaParser.PRIVATE - 1)) | (1 << (JavaParser.PROTECTED - 1)) | (1 << (JavaParser.PUBLIC - 1)) | (1 << (JavaParser.RETURN - 1)) | (1 << (JavaParser.SHORT - 1)) | (1 << (JavaParser.STATIC - 1)) | (1 << (JavaParser.STRICTFP - 1)) | (1 << (JavaParser.SUPER - 1)) | (1 << (JavaParser.SWITCH - 1)) | (1 << (JavaParser.SYNCHRONIZED - 1)) | (1 << (JavaParser.THIS - 1)) | (1 << (JavaParser.THROW - 1)) | (1 << (JavaParser.TRY - 1)) | (1 << (JavaParser.VOID - 1)) | (1 << (JavaParser.WHILE - 1)) | (1 << (JavaParser.MODULE - 1)) | (1 << (JavaParser.OPEN - 1)) | (1 << (JavaParser.REQUIRES - 1)) | (1 << (JavaParser.EXPORTS - 1)) | (1 << (JavaParser.OPENS - 1)) | (1 << (JavaParser.TO - 1)) | (1 << (JavaParser.USES - 1)) | (1 << (JavaParser.PROVIDES - 1)) | (1 << (JavaParser.WITH - 1)) | (1 << (JavaParser.TRANSITIVE - 1)) | (1 << (JavaParser.VAR - 1)) | (1 << (JavaParser.YIELD - 1)) | (1 << (JavaParser.RECORD - 1)) | (1 << (JavaParser.SEALED - 1)))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (JavaParser.PERMITS - 65)) | (1 << (JavaParser.NON_SEALED - 65)) | (1 << (JavaParser.SEMI - 65)) | (1 << (JavaParser.PAREN_S - 65)) | (1 << (JavaParser.BLOCK_S - 65)) | (1 << (JavaParser.DECIMAL_LITERAL - 65)) | (1 << (JavaParser.HEX_LITERAL - 65)) | (1 << (JavaParser.OCT_LITERAL - 65)) | (1 << (JavaParser.BINARY_LITERAL - 65)) | (1 << (JavaParser.FLOAT_LITERAL - 65)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 65)) | (1 << (JavaParser.BOOL_LITERAL - 65)) | (1 << (JavaParser.CHAR_LITERAL - 65)) | (1 << (JavaParser.STRING_LITERAL - 65)) | (1 << (JavaParser.TEXT_BLOCK - 65)) | (1 << (JavaParser.NULL_LITERAL - 65)) | (1 << (JavaParser.LT - 65)) | (1 << (JavaParser.LOG_NOT - 65)) | (1 << (JavaParser.TILDE - 65)) | (1 << (JavaParser.UNN_INC - 65)) | (1 << (JavaParser.UNN_DEC - 65)) | (1 << (JavaParser.ADD - 65)) | (1 << (JavaParser.SUB - 65)) | (1 << (JavaParser.AT - 65)) | (1 << (JavaParser.IDENTIFIER - 65)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_labelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.constantExpression = None # ExpressionContext
            self.enumConstantName = None # Token
            self.varName = None # IdentifierContext

        def CASE(self):
            return self.getToken(JavaParser.CASE, 0)

        def COLON(self):
            return self.getToken(JavaParser.COLON, 0)

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def IDENTIFIER(self):
            return self.getToken(JavaParser.IDENTIFIER, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def DEFAULT(self):
            return self.getToken(JavaParser.DEFAULT, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_switch_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitch_label" ):
                listener.enterSwitch_label(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitch_label" ):
                listener.exitSwitch_label(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitch_label" ):
                return visitor.visitSwitch_label(self)
            else:
                return visitor.visitChildren(self)




    def switch_label(self):

        localctx = JavaParser.Switch_labelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_switch_label)
        try:
            self.state = 1233
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.CASE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1222
                self.match(JavaParser.CASE)
                self.state = 1228
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
                if la_ == 1:
                    self.state = 1223
                    localctx.constantExpression = self.expression(0)
                    pass

                elif la_ == 2:
                    self.state = 1224
                    localctx.enumConstantName = self.match(JavaParser.IDENTIFIER)
                    pass

                elif la_ == 3:
                    self.state = 1225
                    self.type_type()
                    self.state = 1226
                    localctx.varName = self.identifier()
                    pass


                self.state = 1230
                self.match(JavaParser.COLON)
                pass
            elif token in [JavaParser.DEFAULT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1231
                self.match(JavaParser.DEFAULT)
                self.state = 1232
                self.match(JavaParser.COLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_initContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def local_variable_declaration(self):
            return self.getTypedRuleContext(JavaParser.Local_variable_declarationContext,0)


        def expression_list(self):
            return self.getTypedRuleContext(JavaParser.Expression_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_for_init

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_init" ):
                listener.enterFor_init(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_init" ):
                listener.exitFor_init(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_init" ):
                return visitor.visitFor_init(self)
            else:
                return visitor.visitChildren(self)




    def for_init(self):

        localctx = JavaParser.For_initContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_for_init)
        try:
            self.state = 1237
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,150,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1235
                self.local_variable_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1236
                self.expression_list()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_controlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.forUpdate = None # Expression_listContext

        def enhanced_for_control(self):
            return self.getTypedRuleContext(JavaParser.Enhanced_for_controlContext,0)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.SEMI)
            else:
                return self.getToken(JavaParser.SEMI, i)

        def for_init(self):
            return self.getTypedRuleContext(JavaParser.For_initContext,0)


        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def expression_list(self):
            return self.getTypedRuleContext(JavaParser.Expression_listContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_for_control

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_control" ):
                listener.enterFor_control(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_control" ):
                listener.exitFor_control(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_control" ):
                return visitor.visitFor_control(self)
            else:
                return visitor.visitChildren(self)




    def for_control(self):

        localctx = JavaParser.For_controlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_for_control)
        self._la = 0 # Token type
        try:
            self.state = 1251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,154,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1239
                self.enhanced_for_control()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1241
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FINAL - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                    self.state = 1240
                    self.for_init()


                self.state = 1243
                self.match(JavaParser.SEMI)
                self.state = 1245
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                    self.state = 1244
                    self.expression(0)


                self.state = 1247
                self.match(JavaParser.SEMI)
                self.state = 1249
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                    self.state = 1248
                    localctx.forUpdate = self.expression_list()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enhanced_for_controlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_declarator_id(self):
            return self.getTypedRuleContext(JavaParser.Variable_declarator_idContext,0)


        def COLON(self):
            return self.getToken(JavaParser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def VAR(self):
            return self.getToken(JavaParser.VAR, 0)

        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_enhanced_for_control

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnhanced_for_control" ):
                listener.enterEnhanced_for_control(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnhanced_for_control" ):
                listener.exitEnhanced_for_control(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnhanced_for_control" ):
                return visitor.visitEnhanced_for_control(self)
            else:
                return visitor.visitChildren(self)




    def enhanced_for_control(self):

        localctx = JavaParser.Enhanced_for_controlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_enhanced_for_control)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1256
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,155,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1253
                    self.variable_modifier() 
                self.state = 1258
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,155,self._ctx)

            self.state = 1261
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.state = 1259
                self.type_type()
                pass

            elif la_ == 2:
                self.state = 1260
                self.match(JavaParser.VAR)
                pass


            self.state = 1263
            self.variable_declarator_id()
            self.state = 1264
            self.match(JavaParser.COLON)
            self.state = 1265
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Catch_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CATCH(self):
            return self.getToken(JavaParser.CATCH, 0)

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def catch_type(self):
            return self.getTypedRuleContext(JavaParser.Catch_typeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_catch_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatch_clause" ):
                listener.enterCatch_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatch_clause" ):
                listener.exitCatch_clause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCatch_clause" ):
                return visitor.visitCatch_clause(self)
            else:
                return visitor.visitChildren(self)




    def catch_clause(self):

        localctx = JavaParser.Catch_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_catch_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1267
            self.match(JavaParser.CATCH)
            self.state = 1268
            self.match(JavaParser.PAREN_S)
            self.state = 1272
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,157,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1269
                    self.variable_modifier() 
                self.state = 1274
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,157,self._ctx)

            self.state = 1275
            self.catch_type()
            self.state = 1276
            self.identifier()
            self.state = 1277
            self.match(JavaParser.PAREN_E)
            self.state = 1278
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Catch_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Qualified_nameContext)
            else:
                return self.getTypedRuleContext(JavaParser.Qualified_nameContext,i)


        def BITOR(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.BITOR)
            else:
                return self.getToken(JavaParser.BITOR, i)

        def getRuleIndex(self):
            return JavaParser.RULE_catch_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatch_type" ):
                listener.enterCatch_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatch_type" ):
                listener.exitCatch_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCatch_type" ):
                return visitor.visitCatch_type(self)
            else:
                return visitor.visitChildren(self)




    def catch_type(self):

        localctx = JavaParser.Catch_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_catch_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1280
            self.qualified_name()
            self.state = 1285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.BITOR:
                self.state = 1281
                self.match(JavaParser.BITOR)
                self.state = 1282
                self.qualified_name()
                self.state = 1287
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Finally_blockContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FINALLY(self):
            return self.getToken(JavaParser.FINALLY, 0)

        def block(self):
            return self.getTypedRuleContext(JavaParser.BlockContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_finally_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFinally_block" ):
                listener.enterFinally_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFinally_block" ):
                listener.exitFinally_block(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFinally_block" ):
                return visitor.visitFinally_block(self)
            else:
                return visitor.visitChildren(self)




    def finally_block(self):

        localctx = JavaParser.Finally_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_finally_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1288
            self.match(JavaParser.FINALLY)
            self.state = 1289
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Resource_specificationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def resources(self):
            return self.getTypedRuleContext(JavaParser.ResourcesContext,0)


        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def SEMI(self):
            return self.getToken(JavaParser.SEMI, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_resource_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResource_specification" ):
                listener.enterResource_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResource_specification" ):
                listener.exitResource_specification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResource_specification" ):
                return visitor.visitResource_specification(self)
            else:
                return visitor.visitChildren(self)




    def resource_specification(self):

        localctx = JavaParser.Resource_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_resource_specification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1291
            self.match(JavaParser.PAREN_S)
            self.state = 1292
            self.resources()
            self.state = 1294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.SEMI:
                self.state = 1293
                self.match(JavaParser.SEMI)


            self.state = 1296
            self.match(JavaParser.PAREN_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResourcesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def resource(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ResourceContext)
            else:
                return self.getTypedRuleContext(JavaParser.ResourceContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.SEMI)
            else:
                return self.getToken(JavaParser.SEMI, i)

        def getRuleIndex(self):
            return JavaParser.RULE_resources

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResources" ):
                listener.enterResources(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResources" ):
                listener.exitResources(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResources" ):
                return visitor.visitResources(self)
            else:
                return visitor.visitChildren(self)




    def resources(self):

        localctx = JavaParser.ResourcesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_resources)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1298
            self.resource()
            self.state = 1303
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,160,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1299
                    self.match(JavaParser.SEMI)
                    self.state = 1300
                    self.resource() 
                self.state = 1305
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,160,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResourceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(JavaParser.ASSIGN, 0)

        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def class_or_interface_type(self):
            return self.getTypedRuleContext(JavaParser.Class_or_interface_typeContext,0)


        def variable_declarator_id(self):
            return self.getTypedRuleContext(JavaParser.Variable_declarator_idContext,0)


        def VAR(self):
            return self.getToken(JavaParser.VAR, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_resource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResource" ):
                listener.enterResource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResource" ):
                listener.exitResource(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResource" ):
                return visitor.visitResource(self)
            else:
                return visitor.visitChildren(self)




    def resource(self):

        localctx = JavaParser.ResourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_resource)
        try:
            self.state = 1323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1309
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,161,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1306
                        self.variable_modifier() 
                    self.state = 1311
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,161,self._ctx)

                self.state = 1317
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
                if la_ == 1:
                    self.state = 1312
                    self.class_or_interface_type()
                    self.state = 1313
                    self.variable_declarator_id()
                    pass

                elif la_ == 2:
                    self.state = 1315
                    self.match(JavaParser.VAR)
                    self.state = 1316
                    self.identifier()
                    pass


                self.state = 1319
                self.match(JavaParser.ASSIGN)
                self.state = 1320
                self.expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1322
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = JavaParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_pattern)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1328
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,164,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1325
                    self.variable_modifier() 
                self.state = 1330
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,164,self._ctx)

            self.state = 1331
            self.type_type()
            self.state = 1335
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,165,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1332
                    self.annotation() 
                self.state = 1337
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,165,self._ctx)

            self.state = 1338
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def THIS(self):
            return self.getToken(JavaParser.THIS, 0)

        def SUPER(self):
            return self.getToken(JavaParser.SUPER, 0)

        def literal(self):
            return self.getTypedRuleContext(JavaParser.LiteralContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def type_type_or_void(self):
            return self.getTypedRuleContext(JavaParser.Type_type_or_voidContext,0)


        def DOT(self):
            return self.getToken(JavaParser.DOT, 0)

        def CLASS(self):
            return self.getToken(JavaParser.CLASS, 0)

        def non_wildcard_type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Non_wildcard_type_argumentsContext,0)


        def explicit_generic_invocation_suffix(self):
            return self.getTypedRuleContext(JavaParser.Explicit_generic_invocation_suffixContext,0)


        def arguments(self):
            return self.getTypedRuleContext(JavaParser.ArgumentsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary" ):
                return visitor.visitPrimary(self)
            else:
                return visitor.visitChildren(self)




    def primary(self):

        localctx = JavaParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_primary)
        try:
            self.state = 1358
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1340
                self.match(JavaParser.PAREN_S)
                self.state = 1341
                self.expression(0)
                self.state = 1342
                self.match(JavaParser.PAREN_E)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1344
                self.match(JavaParser.THIS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1345
                self.match(JavaParser.SUPER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1346
                self.literal()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1347
                self.identifier()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1348
                self.type_type_or_void()
                self.state = 1349
                self.match(JavaParser.DOT)
                self.state = 1350
                self.match(JavaParser.CLASS)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1352
                self.non_wildcard_type_arguments()
                self.state = 1356
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [JavaParser.SUPER, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.IDENTIFIER]:
                    self.state = 1353
                    self.explicit_generic_invocation_suffix()
                    pass
                elif token in [JavaParser.THIS]:
                    self.state = 1354
                    self.match(JavaParser.THIS)
                    self.state = 1355
                    self.arguments()
                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer_literal(self):
            return self.getTypedRuleContext(JavaParser.Integer_literalContext,0)


        def float_literal(self):
            return self.getTypedRuleContext(JavaParser.Float_literalContext,0)


        def CHAR_LITERAL(self):
            return self.getToken(JavaParser.CHAR_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(JavaParser.STRING_LITERAL, 0)

        def BOOL_LITERAL(self):
            return self.getToken(JavaParser.BOOL_LITERAL, 0)

        def NULL_LITERAL(self):
            return self.getToken(JavaParser.NULL_LITERAL, 0)

        def TEXT_BLOCK(self):
            return self.getToken(JavaParser.TEXT_BLOCK, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = JavaParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_literal)
        try:
            self.state = 1367
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.DECIMAL_LITERAL, JavaParser.HEX_LITERAL, JavaParser.OCT_LITERAL, JavaParser.BINARY_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1360
                self.integer_literal()
                pass
            elif token in [JavaParser.FLOAT_LITERAL, JavaParser.HEX_FLOAT_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1361
                self.float_literal()
                pass
            elif token in [JavaParser.CHAR_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1362
                self.match(JavaParser.CHAR_LITERAL)
                pass
            elif token in [JavaParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1363
                self.match(JavaParser.STRING_LITERAL)
                pass
            elif token in [JavaParser.BOOL_LITERAL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1364
                self.match(JavaParser.BOOL_LITERAL)
                pass
            elif token in [JavaParser.NULL_LITERAL]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1365
                self.match(JavaParser.NULL_LITERAL)
                pass
            elif token in [JavaParser.TEXT_BLOCK]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1366
                self.match(JavaParser.TEXT_BLOCK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Integer_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECIMAL_LITERAL(self):
            return self.getToken(JavaParser.DECIMAL_LITERAL, 0)

        def HEX_LITERAL(self):
            return self.getToken(JavaParser.HEX_LITERAL, 0)

        def OCT_LITERAL(self):
            return self.getToken(JavaParser.OCT_LITERAL, 0)

        def BINARY_LITERAL(self):
            return self.getToken(JavaParser.BINARY_LITERAL, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_integer_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteger_literal" ):
                listener.enterInteger_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteger_literal" ):
                listener.exitInteger_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteger_literal" ):
                return visitor.visitInteger_literal(self)
            else:
                return visitor.visitChildren(self)




    def integer_literal(self):

        localctx = JavaParser.Integer_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_integer_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1369
            _la = self._input.LA(1)
            if not(((((_la - 76)) & ~0x3f) == 0 and ((1 << (_la - 76)) & ((1 << (JavaParser.DECIMAL_LITERAL - 76)) | (1 << (JavaParser.HEX_LITERAL - 76)) | (1 << (JavaParser.OCT_LITERAL - 76)) | (1 << (JavaParser.BINARY_LITERAL - 76)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Float_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT_LITERAL(self):
            return self.getToken(JavaParser.FLOAT_LITERAL, 0)

        def HEX_FLOAT_LITERAL(self):
            return self.getToken(JavaParser.HEX_FLOAT_LITERAL, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_float_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloat_literal" ):
                listener.enterFloat_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloat_literal" ):
                listener.exitFloat_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloat_literal" ):
                return visitor.visitFloat_literal(self)
            else:
                return visitor.visitChildren(self)




    def float_literal(self):

        localctx = JavaParser.Float_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_float_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1371
            _la = self._input.LA(1)
            if not(_la==JavaParser.FLOAT_LITERAL or _la==JavaParser.HEX_FLOAT_LITERAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_arguments_or_diamondContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(JavaParser.LT, 0)

        def GT(self):
            return self.getToken(JavaParser.GT, 0)

        def type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Type_argumentsContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_type_arguments_or_diamond

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_arguments_or_diamond" ):
                listener.enterType_arguments_or_diamond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_arguments_or_diamond" ):
                listener.exitType_arguments_or_diamond(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_arguments_or_diamond" ):
                return visitor.visitType_arguments_or_diamond(self)
            else:
                return visitor.visitChildren(self)




    def type_arguments_or_diamond(self):

        localctx = JavaParser.Type_arguments_or_diamondContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_type_arguments_or_diamond)
        try:
            self.state = 1376
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1373
                self.match(JavaParser.LT)
                self.state = 1374
                self.match(JavaParser.GT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1375
                self.type_arguments()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.prefix = None # Token
            self.bop = None # Token
            self.postfix = None # Token

        def primary(self):
            return self.getTypedRuleContext(JavaParser.PrimaryContext,0)


        def method_call(self):
            return self.getTypedRuleContext(JavaParser.Method_callContext,0)


        def NEW(self):
            return self.getToken(JavaParser.NEW, 0)

        def creator(self):
            return self.getTypedRuleContext(JavaParser.CreatorContext,0)


        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def type_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_typeContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_typeContext,i)


        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(JavaParser.ExpressionContext,i)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def BITAND(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.BITAND)
            else:
                return self.getToken(JavaParser.BITAND, i)

        def ADD(self):
            return self.getToken(JavaParser.ADD, 0)

        def SUB(self):
            return self.getToken(JavaParser.SUB, 0)

        def UNN_INC(self):
            return self.getToken(JavaParser.UNN_INC, 0)

        def UNN_DEC(self):
            return self.getToken(JavaParser.UNN_DEC, 0)

        def TILDE(self):
            return self.getToken(JavaParser.TILDE, 0)

        def LOG_NOT(self):
            return self.getToken(JavaParser.LOG_NOT, 0)

        def switch_expression(self):
            return self.getTypedRuleContext(JavaParser.Switch_expressionContext,0)


        def COLONCOLON(self):
            return self.getToken(JavaParser.COLONCOLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Type_argumentsContext,0)


        def class_type(self):
            return self.getTypedRuleContext(JavaParser.Class_typeContext,0)


        def MUL(self):
            return self.getToken(JavaParser.MUL, 0)

        def DIV(self):
            return self.getToken(JavaParser.DIV, 0)

        def MOD(self):
            return self.getToken(JavaParser.MOD, 0)

        def LT(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.LT)
            else:
                return self.getToken(JavaParser.LT, i)

        def GT(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.GT)
            else:
                return self.getToken(JavaParser.GT, i)

        def LE(self):
            return self.getToken(JavaParser.LE, 0)

        def GE(self):
            return self.getToken(JavaParser.GE, 0)

        def EQUAL(self):
            return self.getToken(JavaParser.EQUAL, 0)

        def NOTEQUAL(self):
            return self.getToken(JavaParser.NOTEQUAL, 0)

        def CARET(self):
            return self.getToken(JavaParser.CARET, 0)

        def BITOR(self):
            return self.getToken(JavaParser.BITOR, 0)

        def LOG_AND(self):
            return self.getToken(JavaParser.LOG_AND, 0)

        def LOG_OR(self):
            return self.getToken(JavaParser.LOG_OR, 0)

        def COLON(self):
            return self.getToken(JavaParser.COLON, 0)

        def QUESTION(self):
            return self.getToken(JavaParser.QUESTION, 0)

        def ASSIGN(self):
            return self.getToken(JavaParser.ASSIGN, 0)

        def ADD_ASS(self):
            return self.getToken(JavaParser.ADD_ASS, 0)

        def SUB_ASS(self):
            return self.getToken(JavaParser.SUB_ASS, 0)

        def MUL_ASS(self):
            return self.getToken(JavaParser.MUL_ASS, 0)

        def DIV_ASS(self):
            return self.getToken(JavaParser.DIV_ASS, 0)

        def AND_ASS(self):
            return self.getToken(JavaParser.AND_ASS, 0)

        def OR_ASS(self):
            return self.getToken(JavaParser.OR_ASS, 0)

        def XOR_ASS(self):
            return self.getToken(JavaParser.XOR_ASS, 0)

        def RSHIFT_ASS(self):
            return self.getToken(JavaParser.RSHIFT_ASS, 0)

        def URSHIFT_ASS(self):
            return self.getToken(JavaParser.URSHIFT_ASS, 0)

        def LSHIFT_ASS(self):
            return self.getToken(JavaParser.LSHIFT_ASS, 0)

        def MOD_ASS(self):
            return self.getToken(JavaParser.MOD_ASS, 0)

        def DOT(self):
            return self.getToken(JavaParser.DOT, 0)

        def THIS(self):
            return self.getToken(JavaParser.THIS, 0)

        def inner_creator(self):
            return self.getTypedRuleContext(JavaParser.Inner_creatorContext,0)


        def SUPER(self):
            return self.getToken(JavaParser.SUPER, 0)

        def super_suffix(self):
            return self.getTypedRuleContext(JavaParser.Super_suffixContext,0)


        def explicit_generic_invocation(self):
            return self.getTypedRuleContext(JavaParser.Explicit_generic_invocationContext,0)


        def non_wildcard_type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Non_wildcard_type_argumentsContext,0)


        def ARRAY_S(self):
            return self.getToken(JavaParser.ARRAY_S, 0)

        def ARRAY_E(self):
            return self.getToken(JavaParser.ARRAY_E, 0)

        def INSTANCEOF(self):
            return self.getToken(JavaParser.INSTANCEOF, 0)

        def pattern(self):
            return self.getTypedRuleContext(JavaParser.PatternContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = JavaParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 208
        self.enterRecursionRule(localctx, 208, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1422
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
            if la_ == 1:
                self.state = 1379
                self.primary()
                pass

            elif la_ == 2:
                self.state = 1380
                self.method_call()
                pass

            elif la_ == 3:
                self.state = 1381
                self.match(JavaParser.NEW)
                self.state = 1382
                self.creator()
                pass

            elif la_ == 4:
                self.state = 1383
                self.match(JavaParser.PAREN_S)
                self.state = 1387
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,170,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1384
                        self.annotation() 
                    self.state = 1389
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,170,self._ctx)

                self.state = 1390
                self.type_type()
                self.state = 1395
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==JavaParser.BITAND:
                    self.state = 1391
                    self.match(JavaParser.BITAND)
                    self.state = 1392
                    self.type_type()
                    self.state = 1397
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1398
                self.match(JavaParser.PAREN_E)
                self.state = 1399
                self.expression(21)
                pass

            elif la_ == 5:
                self.state = 1401
                localctx.prefix = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 103)) & ~0x3f) == 0 and ((1 << (_la - 103)) & ((1 << (JavaParser.UNN_INC - 103)) | (1 << (JavaParser.UNN_DEC - 103)) | (1 << (JavaParser.ADD - 103)) | (1 << (JavaParser.SUB - 103)))) != 0)):
                    localctx.prefix = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1402
                self.expression(19)
                pass

            elif la_ == 6:
                self.state = 1403
                localctx.prefix = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==JavaParser.LOG_NOT or _la==JavaParser.TILDE):
                    localctx.prefix = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1404
                self.expression(18)
                pass

            elif la_ == 7:
                self.state = 1405
                self.switch_expression()
                pass

            elif la_ == 8:
                self.state = 1406
                self.type_type()
                self.state = 1407
                self.match(JavaParser.COLONCOLON)
                self.state = 1413
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.LT, JavaParser.IDENTIFIER]:
                    self.state = 1409
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==JavaParser.LT:
                        self.state = 1408
                        self.type_arguments()


                    self.state = 1411
                    self.identifier()
                    pass
                elif token in [JavaParser.NEW]:
                    self.state = 1412
                    self.match(JavaParser.NEW)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 9:
                self.state = 1415
                self.class_type()
                self.state = 1416
                self.match(JavaParser.COLONCOLON)
                self.state = 1418
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.LT:
                    self.state = 1417
                    self.type_arguments()


                self.state = 1420
                self.match(JavaParser.NEW)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1507
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,182,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1505
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,181,self._ctx)
                    if la_ == 1:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1424
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 1425
                        localctx.bop = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 107)) & ~0x3f) == 0 and ((1 << (_la - 107)) & ((1 << (JavaParser.MUL - 107)) | (1 << (JavaParser.DIV - 107)) | (1 << (JavaParser.MOD - 107)))) != 0)):
                            localctx.bop = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1426
                        self.expression(18)
                        pass

                    elif la_ == 2:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1427
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 1428
                        localctx.bop = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==JavaParser.ADD or _la==JavaParser.SUB):
                            localctx.bop = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1429
                        self.expression(17)
                        pass

                    elif la_ == 3:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1430
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 1438
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,176,self._ctx)
                        if la_ == 1:
                            self.state = 1431
                            self.match(JavaParser.LT)
                            self.state = 1432
                            self.match(JavaParser.LT)
                            pass

                        elif la_ == 2:
                            self.state = 1433
                            self.match(JavaParser.GT)
                            self.state = 1434
                            self.match(JavaParser.GT)
                            self.state = 1435
                            self.match(JavaParser.GT)
                            pass

                        elif la_ == 3:
                            self.state = 1436
                            self.match(JavaParser.GT)
                            self.state = 1437
                            self.match(JavaParser.GT)
                            pass


                        self.state = 1440
                        self.expression(16)
                        pass

                    elif la_ == 4:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1441
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 1442
                        localctx.bop = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 91)) & ~0x3f) == 0 and ((1 << (_la - 91)) & ((1 << (JavaParser.GT - 91)) | (1 << (JavaParser.LT - 91)) | (1 << (JavaParser.LE - 91)) | (1 << (JavaParser.GE - 91)))) != 0)):
                            localctx.bop = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1443
                        self.expression(15)
                        pass

                    elif la_ == 5:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1444
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 1445
                        localctx.bop = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==JavaParser.EQUAL or _la==JavaParser.NOTEQUAL):
                            localctx.bop = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1446
                        self.expression(13)
                        pass

                    elif la_ == 6:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1447
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 1448
                        localctx.bop = self.match(JavaParser.BITAND)
                        self.state = 1449
                        self.expression(12)
                        pass

                    elif la_ == 7:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1450
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 1451
                        localctx.bop = self.match(JavaParser.CARET)
                        self.state = 1452
                        self.expression(11)
                        pass

                    elif la_ == 8:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1453
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 1454
                        localctx.bop = self.match(JavaParser.BITOR)
                        self.state = 1455
                        self.expression(10)
                        pass

                    elif la_ == 9:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1456
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 1457
                        localctx.bop = self.match(JavaParser.LOG_AND)
                        self.state = 1458
                        self.expression(9)
                        pass

                    elif la_ == 10:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1459
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 1460
                        localctx.bop = self.match(JavaParser.LOG_OR)
                        self.state = 1461
                        self.expression(8)
                        pass

                    elif la_ == 11:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1462
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 1463
                        localctx.bop = self.match(JavaParser.QUESTION)
                        self.state = 1464
                        self.expression(0)
                        self.state = 1465
                        self.match(JavaParser.COLON)
                        self.state = 1466
                        self.expression(6)
                        pass

                    elif la_ == 12:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1468
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 1469
                        localctx.bop = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & ((1 << (JavaParser.ASSIGN - 90)) | (1 << (JavaParser.ADD_ASS - 90)) | (1 << (JavaParser.SUB_ASS - 90)) | (1 << (JavaParser.MUL_ASS - 90)) | (1 << (JavaParser.DIV_ASS - 90)) | (1 << (JavaParser.AND_ASS - 90)) | (1 << (JavaParser.OR_ASS - 90)) | (1 << (JavaParser.XOR_ASS - 90)) | (1 << (JavaParser.MOD_ASS - 90)) | (1 << (JavaParser.LSHIFT_ASS - 90)) | (1 << (JavaParser.RSHIFT_ASS - 90)) | (1 << (JavaParser.URSHIFT_ASS - 90)))) != 0)):
                            localctx.bop = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1470
                        self.expression(5)
                        pass

                    elif la_ == 13:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1471
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 1472
                        localctx.bop = self.match(JavaParser.DOT)
                        self.state = 1484
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,178,self._ctx)
                        if la_ == 1:
                            self.state = 1473
                            self.identifier()
                            pass

                        elif la_ == 2:
                            self.state = 1474
                            self.method_call()
                            pass

                        elif la_ == 3:
                            self.state = 1475
                            self.match(JavaParser.THIS)
                            pass

                        elif la_ == 4:
                            self.state = 1476
                            self.match(JavaParser.NEW)
                            self.state = 1478
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==JavaParser.LT:
                                self.state = 1477
                                self.non_wildcard_type_arguments()


                            self.state = 1480
                            self.inner_creator()
                            pass

                        elif la_ == 5:
                            self.state = 1481
                            self.match(JavaParser.SUPER)
                            self.state = 1482
                            self.super_suffix()
                            pass

                        elif la_ == 6:
                            self.state = 1483
                            self.explicit_generic_invocation()
                            pass


                        pass

                    elif la_ == 14:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1486
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 1487
                        self.match(JavaParser.ARRAY_S)
                        self.state = 1488
                        self.expression(0)
                        self.state = 1489
                        self.match(JavaParser.ARRAY_E)
                        pass

                    elif la_ == 15:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1491
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 1492
                        localctx.postfix = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==JavaParser.UNN_INC or _la==JavaParser.UNN_DEC):
                            localctx.postfix = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass

                    elif la_ == 16:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1493
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 1494
                        localctx.bop = self.match(JavaParser.INSTANCEOF)
                        self.state = 1497
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
                        if la_ == 1:
                            self.state = 1495
                            self.type_type()
                            pass

                        elif la_ == 2:
                            self.state = 1496
                            self.pattern()
                            pass


                        pass

                    elif la_ == 17:
                        localctx = JavaParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 1499
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 1500
                        self.match(JavaParser.COLONCOLON)
                        self.state = 1502
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==JavaParser.LT:
                            self.state = 1501
                            self.type_arguments()


                        self.state = 1504
                        self.identifier()
                        pass

             
                self.state = 1509
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,182,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Switch_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SWITCH(self):
            return self.getToken(JavaParser.SWITCH, 0)

        def par_expression(self):
            return self.getTypedRuleContext(JavaParser.Par_expressionContext,0)


        def BLOCK_S(self):
            return self.getToken(JavaParser.BLOCK_S, 0)

        def BLOCK_E(self):
            return self.getToken(JavaParser.BLOCK_E, 0)

        def switch_labeled_rule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Switch_labeled_ruleContext)
            else:
                return self.getTypedRuleContext(JavaParser.Switch_labeled_ruleContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_switch_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitch_expression" ):
                listener.enterSwitch_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitch_expression" ):
                listener.exitSwitch_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitch_expression" ):
                return visitor.visitSwitch_expression(self)
            else:
                return visitor.visitChildren(self)




    def switch_expression(self):

        localctx = JavaParser.Switch_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_switch_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1510
            self.match(JavaParser.SWITCH)
            self.state = 1511
            self.par_expression()
            self.state = 1512
            self.match(JavaParser.BLOCK_S)
            self.state = 1516
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.CASE or _la==JavaParser.DEFAULT:
                self.state = 1513
                self.switch_labeled_rule()
                self.state = 1518
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1519
            self.match(JavaParser.BLOCK_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_labeled_ruleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(JavaParser.CASE, 0)

        def switch_rule_outcome(self):
            return self.getTypedRuleContext(JavaParser.Switch_rule_outcomeContext,0)


        def ARROW(self):
            return self.getToken(JavaParser.ARROW, 0)

        def COLON(self):
            return self.getToken(JavaParser.COLON, 0)

        def expression_list(self):
            return self.getTypedRuleContext(JavaParser.Expression_listContext,0)


        def NULL_LITERAL(self):
            return self.getToken(JavaParser.NULL_LITERAL, 0)

        def guarded_pattern(self):
            return self.getTypedRuleContext(JavaParser.Guarded_patternContext,0)


        def DEFAULT(self):
            return self.getToken(JavaParser.DEFAULT, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_switch_labeled_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitch_labeled_rule" ):
                listener.enterSwitch_labeled_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitch_labeled_rule" ):
                listener.exitSwitch_labeled_rule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitch_labeled_rule" ):
                return visitor.visitSwitch_labeled_rule(self)
            else:
                return visitor.visitChildren(self)




    def switch_labeled_rule(self):

        localctx = JavaParser.Switch_labeled_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_switch_labeled_rule)
        self._la = 0 # Token type
        try:
            self.state = 1532
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.CASE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1521
                self.match(JavaParser.CASE)
                self.state = 1525
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,184,self._ctx)
                if la_ == 1:
                    self.state = 1522
                    self.expression_list()
                    pass

                elif la_ == 2:
                    self.state = 1523
                    self.match(JavaParser.NULL_LITERAL)
                    pass

                elif la_ == 3:
                    self.state = 1524
                    self.guarded_pattern(0)
                    pass


                self.state = 1527
                _la = self._input.LA(1)
                if not(_la==JavaParser.COLON or _la==JavaParser.ARROW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1528
                self.switch_rule_outcome()
                pass
            elif token in [JavaParser.DEFAULT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1529
                self.match(JavaParser.DEFAULT)
                self.state = 1530
                _la = self._input.LA(1)
                if not(_la==JavaParser.COLON or _la==JavaParser.ARROW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1531
                self.switch_rule_outcome()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qualified_name_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Qualified_nameContext)
            else:
                return self.getTypedRuleContext(JavaParser.Qualified_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_qualified_name_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualified_name_list" ):
                listener.enterQualified_name_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualified_name_list" ):
                listener.exitQualified_name_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualified_name_list" ):
                return visitor.visitQualified_name_list(self)
            else:
                return visitor.visitChildren(self)




    def qualified_name_list(self):

        localctx = JavaParser.Qualified_name_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_qualified_name_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1534
            self.qualified_name()
            self.state = 1539
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 1535
                self.match(JavaParser.COMMA)
                self.state = 1536
                self.qualified_name()
                self.state = 1541
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Last_formal_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def ELLIPSIS(self):
            return self.getToken(JavaParser.ELLIPSIS, 0)

        def variable_declarator_id(self):
            return self.getTypedRuleContext(JavaParser.Variable_declarator_idContext,0)


        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_last_formal_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLast_formal_parameter" ):
                listener.enterLast_formal_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLast_formal_parameter" ):
                listener.exitLast_formal_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLast_formal_parameter" ):
                return visitor.visitLast_formal_parameter(self)
            else:
                return visitor.visitChildren(self)




    def last_formal_parameter(self):

        localctx = JavaParser.Last_formal_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_last_formal_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1545
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,187,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1542
                    self.variable_modifier() 
                self.state = 1547
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,187,self._ctx)

            self.state = 1548
            self.type_type()
            self.state = 1552
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (JavaParser.MODULE - 51)) | (1 << (JavaParser.OPEN - 51)) | (1 << (JavaParser.REQUIRES - 51)) | (1 << (JavaParser.EXPORTS - 51)) | (1 << (JavaParser.OPENS - 51)) | (1 << (JavaParser.TO - 51)) | (1 << (JavaParser.USES - 51)) | (1 << (JavaParser.PROVIDES - 51)) | (1 << (JavaParser.WITH - 51)) | (1 << (JavaParser.TRANSITIVE - 51)) | (1 << (JavaParser.VAR - 51)) | (1 << (JavaParser.YIELD - 51)) | (1 << (JavaParser.RECORD - 51)) | (1 << (JavaParser.SEALED - 51)) | (1 << (JavaParser.PERMITS - 51)))) != 0) or _la==JavaParser.AT or _la==JavaParser.IDENTIFIER:
                self.state = 1549
                self.annotation()
                self.state = 1554
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1555
            self.match(JavaParser.ELLIPSIS)
            self.state = 1556
            self.variable_declarator_id()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qualified_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.IdentifierContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.DOT)
            else:
                return self.getToken(JavaParser.DOT, i)

        def getRuleIndex(self):
            return JavaParser.RULE_qualified_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualified_name" ):
                listener.enterQualified_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualified_name" ):
                listener.exitQualified_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualified_name" ):
                return visitor.visitQualified_name(self)
            else:
                return visitor.visitChildren(self)




    def qualified_name(self):

        localctx = JavaParser.Qualified_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_qualified_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1558
            self.identifier()
            self.state = 1563
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,189,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1559
                    self.match(JavaParser.DOT)
                    self.state = 1560
                    self.identifier() 
                self.state = 1565
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,189,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_type_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def class_declaration(self):
            return self.getTypedRuleContext(JavaParser.Class_declarationContext,0)


        def interface_declaration(self):
            return self.getTypedRuleContext(JavaParser.Interface_declarationContext,0)


        def record_declaration(self):
            return self.getTypedRuleContext(JavaParser.Record_declarationContext,0)


        def class_or_interface_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Class_or_interface_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Class_or_interface_modifierContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_local_type_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocal_type_declaration" ):
                listener.enterLocal_type_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocal_type_declaration" ):
                listener.exitLocal_type_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocal_type_declaration" ):
                return visitor.visitLocal_type_declaration(self)
            else:
                return visitor.visitChildren(self)




    def local_type_declaration(self):

        localctx = JavaParser.Local_type_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_local_type_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1569
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,190,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1566
                    self.class_or_interface_modifier() 
                self.state = 1571
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,190,self._ctx)

            self.state = 1575
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.CLASS]:
                self.state = 1572
                self.class_declaration()
                pass
            elif token in [JavaParser.INTERFACE]:
                self.state = 1573
                self.interface_declaration()
                pass
            elif token in [JavaParser.RECORD]:
                self.state = 1574
                self.record_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Par_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def expression(self):
            return self.getTypedRuleContext(JavaParser.ExpressionContext,0)


        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_par_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_expression" ):
                listener.enterPar_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_expression" ):
                listener.exitPar_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPar_expression" ):
                return visitor.visitPar_expression(self)
            else:
                return visitor.visitChildren(self)




    def par_expression(self):

        localctx = JavaParser.Par_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_par_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1577
            self.match(JavaParser.PAREN_S)
            self.state = 1578
            self.expression(0)
            self.state = 1579
            self.match(JavaParser.PAREN_E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(JavaParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.COMMA)
            else:
                return self.getToken(JavaParser.COMMA, i)

        def getRuleIndex(self):
            return JavaParser.RULE_expression_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression_list" ):
                listener.enterExpression_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression_list" ):
                listener.exitExpression_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression_list" ):
                return visitor.visitExpression_list(self)
            else:
                return visitor.visitChildren(self)




    def expression_list(self):

        localctx = JavaParser.Expression_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_expression_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1581
            self.expression(0)
            self.state = 1586
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JavaParser.COMMA:
                self.state = 1582
                self.match(JavaParser.COMMA)
                self.state = 1583
                self.expression(0)
                self.state = 1588
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Method_callContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def expression_list(self):
            return self.getTypedRuleContext(JavaParser.Expression_listContext,0)


        def THIS(self):
            return self.getToken(JavaParser.THIS, 0)

        def SUPER(self):
            return self.getToken(JavaParser.SUPER, 0)

        def getRuleIndex(self):
            return JavaParser.RULE_method_call

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethod_call" ):
                listener.enterMethod_call(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethod_call" ):
                listener.exitMethod_call(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethod_call" ):
                return visitor.visitMethod_call(self)
            else:
                return visitor.visitChildren(self)




    def method_call(self):

        localctx = JavaParser.Method_callContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_method_call)
        self._la = 0 # Token type
        try:
            self.state = 1608
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1589
                self.identifier()
                self.state = 1590
                self.match(JavaParser.PAREN_S)
                self.state = 1592
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                    self.state = 1591
                    self.expression_list()


                self.state = 1594
                self.match(JavaParser.PAREN_E)
                pass
            elif token in [JavaParser.THIS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1596
                self.match(JavaParser.THIS)
                self.state = 1597
                self.match(JavaParser.PAREN_S)
                self.state = 1599
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                    self.state = 1598
                    self.expression_list()


                self.state = 1601
                self.match(JavaParser.PAREN_E)
                pass
            elif token in [JavaParser.SUPER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1602
                self.match(JavaParser.SUPER)
                self.state = 1603
                self.match(JavaParser.PAREN_S)
                self.state = 1605
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 3)) & ~0x3f) == 0 and ((1 << (_la - 3)) & ((1 << (JavaParser.BOOLEAN - 3)) | (1 << (JavaParser.BYTE - 3)) | (1 << (JavaParser.CHAR - 3)) | (1 << (JavaParser.DOUBLE - 3)) | (1 << (JavaParser.FLOAT - 3)) | (1 << (JavaParser.INT - 3)) | (1 << (JavaParser.LONG - 3)) | (1 << (JavaParser.NEW - 3)) | (1 << (JavaParser.SHORT - 3)) | (1 << (JavaParser.SUPER - 3)) | (1 << (JavaParser.SWITCH - 3)) | (1 << (JavaParser.THIS - 3)) | (1 << (JavaParser.VOID - 3)) | (1 << (JavaParser.MODULE - 3)) | (1 << (JavaParser.OPEN - 3)) | (1 << (JavaParser.REQUIRES - 3)) | (1 << (JavaParser.EXPORTS - 3)) | (1 << (JavaParser.OPENS - 3)) | (1 << (JavaParser.TO - 3)) | (1 << (JavaParser.USES - 3)) | (1 << (JavaParser.PROVIDES - 3)) | (1 << (JavaParser.WITH - 3)) | (1 << (JavaParser.TRANSITIVE - 3)) | (1 << (JavaParser.VAR - 3)) | (1 << (JavaParser.YIELD - 3)) | (1 << (JavaParser.RECORD - 3)) | (1 << (JavaParser.SEALED - 3)) | (1 << (JavaParser.PERMITS - 3)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (JavaParser.PAREN_S - 70)) | (1 << (JavaParser.DECIMAL_LITERAL - 70)) | (1 << (JavaParser.HEX_LITERAL - 70)) | (1 << (JavaParser.OCT_LITERAL - 70)) | (1 << (JavaParser.BINARY_LITERAL - 70)) | (1 << (JavaParser.FLOAT_LITERAL - 70)) | (1 << (JavaParser.HEX_FLOAT_LITERAL - 70)) | (1 << (JavaParser.BOOL_LITERAL - 70)) | (1 << (JavaParser.CHAR_LITERAL - 70)) | (1 << (JavaParser.STRING_LITERAL - 70)) | (1 << (JavaParser.TEXT_BLOCK - 70)) | (1 << (JavaParser.NULL_LITERAL - 70)) | (1 << (JavaParser.LT - 70)) | (1 << (JavaParser.LOG_NOT - 70)) | (1 << (JavaParser.TILDE - 70)) | (1 << (JavaParser.UNN_INC - 70)) | (1 << (JavaParser.UNN_DEC - 70)) | (1 << (JavaParser.ADD - 70)) | (1 << (JavaParser.SUB - 70)) | (1 << (JavaParser.AT - 70)) | (1 << (JavaParser.IDENTIFIER - 70)))) != 0):
                    self.state = 1604
                    self.expression_list()


                self.state = 1607
                self.match(JavaParser.PAREN_E)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Guarded_patternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAREN_S(self):
            return self.getToken(JavaParser.PAREN_S, 0)

        def guarded_pattern(self):
            return self.getTypedRuleContext(JavaParser.Guarded_patternContext,0)


        def PAREN_E(self):
            return self.getToken(JavaParser.PAREN_E, 0)

        def type_type(self):
            return self.getTypedRuleContext(JavaParser.Type_typeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def variable_modifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Variable_modifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.Variable_modifierContext,i)


        def annotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.AnnotationContext)
            else:
                return self.getTypedRuleContext(JavaParser.AnnotationContext,i)


        def LOG_AND(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.LOG_AND)
            else:
                return self.getToken(JavaParser.LOG_AND, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(JavaParser.ExpressionContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_guarded_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuarded_pattern" ):
                listener.enterGuarded_pattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuarded_pattern" ):
                listener.exitGuarded_pattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuarded_pattern" ):
                return visitor.visitGuarded_pattern(self)
            else:
                return visitor.visitChildren(self)



    def guarded_pattern(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = JavaParser.Guarded_patternContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 228
        self.enterRecursionRule(localctx, 228, self.RULE_guarded_pattern, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1636
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.PAREN_S]:
                self.state = 1611
                self.match(JavaParser.PAREN_S)
                self.state = 1612
                self.guarded_pattern(0)
                self.state = 1613
                self.match(JavaParser.PAREN_E)
                pass
            elif token in [JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.DOUBLE, JavaParser.FINAL, JavaParser.FLOAT, JavaParser.INT, JavaParser.LONG, JavaParser.SHORT, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.state = 1618
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,197,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1615
                        self.variable_modifier() 
                    self.state = 1620
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,197,self._ctx)

                self.state = 1621
                self.type_type()
                self.state = 1625
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,198,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1622
                        self.annotation() 
                    self.state = 1627
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,198,self._ctx)

                self.state = 1628
                self.identifier()
                self.state = 1633
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,199,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1629
                        self.match(JavaParser.LOG_AND)
                        self.state = 1630
                        self.expression(0) 
                    self.state = 1635
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,199,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 1643
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,201,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = JavaParser.Guarded_patternContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_guarded_pattern)
                    self.state = 1638
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 1639
                    self.match(JavaParser.LOG_AND)
                    self.state = 1640
                    self.expression(0) 
                self.state = 1645
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,201,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class CreatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def non_wildcard_type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Non_wildcard_type_argumentsContext,0)


        def created_name(self):
            return self.getTypedRuleContext(JavaParser.Created_nameContext,0)


        def class_creator_rest(self):
            return self.getTypedRuleContext(JavaParser.Class_creator_restContext,0)


        def array_creator_rest(self):
            return self.getTypedRuleContext(JavaParser.Array_creator_restContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_creator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreator" ):
                listener.enterCreator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreator" ):
                listener.exitCreator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreator" ):
                return visitor.visitCreator(self)
            else:
                return visitor.visitChildren(self)




    def creator(self):

        localctx = JavaParser.CreatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_creator)
        try:
            self.state = 1655
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.LT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1646
                self.non_wildcard_type_arguments()
                self.state = 1647
                self.created_name()
                self.state = 1648
                self.class_creator_rest()
                pass
            elif token in [JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.DOUBLE, JavaParser.FLOAT, JavaParser.INT, JavaParser.LONG, JavaParser.SHORT, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1650
                self.created_name()
                self.state = 1653
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [JavaParser.ARRAY_S]:
                    self.state = 1651
                    self.array_creator_rest()
                    pass
                elif token in [JavaParser.PAREN_S]:
                    self.state = 1652
                    self.class_creator_rest()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Created_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(JavaParser.IdentifierContext,i)


        def type_arguments_or_diamond(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.Type_arguments_or_diamondContext)
            else:
                return self.getTypedRuleContext(JavaParser.Type_arguments_or_diamondContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.DOT)
            else:
                return self.getToken(JavaParser.DOT, i)

        def primitive_type(self):
            return self.getTypedRuleContext(JavaParser.Primitive_typeContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_created_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreated_name" ):
                listener.enterCreated_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreated_name" ):
                listener.exitCreated_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreated_name" ):
                return visitor.visitCreated_name(self)
            else:
                return visitor.visitChildren(self)




    def created_name(self):

        localctx = JavaParser.Created_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_created_name)
        self._la = 0 # Token type
        try:
            self.state = 1672
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1657
                self.identifier()
                self.state = 1659
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==JavaParser.LT:
                    self.state = 1658
                    self.type_arguments_or_diamond()


                self.state = 1668
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==JavaParser.DOT:
                    self.state = 1661
                    self.match(JavaParser.DOT)
                    self.state = 1662
                    self.identifier()
                    self.state = 1664
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==JavaParser.LT:
                        self.state = 1663
                        self.type_arguments_or_diamond()


                    self.state = 1670
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.DOUBLE, JavaParser.FLOAT, JavaParser.INT, JavaParser.LONG, JavaParser.SHORT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1671
                self.primitive_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Inner_creatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(JavaParser.IdentifierContext,0)


        def class_creator_rest(self):
            return self.getTypedRuleContext(JavaParser.Class_creator_restContext,0)


        def non_wild_card_type_arguments_or_diamond(self):
            return self.getTypedRuleContext(JavaParser.Non_wild_card_type_arguments_or_diamondContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_inner_creator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInner_creator" ):
                listener.enterInner_creator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInner_creator" ):
                listener.exitInner_creator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInner_creator" ):
                return visitor.visitInner_creator(self)
            else:
                return visitor.visitChildren(self)




    def inner_creator(self):

        localctx = JavaParser.Inner_creatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_inner_creator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1674
            self.identifier()
            self.state = 1676
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JavaParser.LT:
                self.state = 1675
                self.non_wild_card_type_arguments_or_diamond()


            self.state = 1678
            self.class_creator_rest()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_creator_restContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY_S(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_S)
            else:
                return self.getToken(JavaParser.ARRAY_S, i)

        def ARRAY_E(self, i:int=None):
            if i is None:
                return self.getTokens(JavaParser.ARRAY_E)
            else:
                return self.getToken(JavaParser.ARRAY_E, i)

        def array_initializer(self):
            return self.getTypedRuleContext(JavaParser.Array_initializerContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JavaParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(JavaParser.ExpressionContext,i)


        def getRuleIndex(self):
            return JavaParser.RULE_array_creator_rest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_creator_rest" ):
                listener.enterArray_creator_rest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_creator_rest" ):
                listener.exitArray_creator_rest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_creator_rest" ):
                return visitor.visitArray_creator_rest(self)
            else:
                return visitor.visitChildren(self)




    def array_creator_rest(self):

        localctx = JavaParser.Array_creator_restContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_array_creator_rest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1680
            self.match(JavaParser.ARRAY_S)
            self.state = 1708
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JavaParser.ARRAY_E]:
                self.state = 1681
                self.match(JavaParser.ARRAY_E)
                self.state = 1686
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==JavaParser.ARRAY_S:
                    self.state = 1682
                    self.match(JavaParser.ARRAY_S)
                    self.state = 1683
                    self.match(JavaParser.ARRAY_E)
                    self.state = 1688
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1689
                self.array_initializer()
                pass
            elif token in [JavaParser.BOOLEAN, JavaParser.BYTE, JavaParser.CHAR, JavaParser.DOUBLE, JavaParser.FLOAT, JavaParser.INT, JavaParser.LONG, JavaParser.NEW, JavaParser.SHORT, JavaParser.SUPER, JavaParser.SWITCH, JavaParser.THIS, JavaParser.VOID, JavaParser.MODULE, JavaParser.OPEN, JavaParser.REQUIRES, JavaParser.EXPORTS, JavaParser.OPENS, JavaParser.TO, JavaParser.USES, JavaParser.PROVIDES, JavaParser.WITH, JavaParser.TRANSITIVE, JavaParser.VAR, JavaParser.YIELD, JavaParser.RECORD, JavaParser.SEALED, JavaParser.PERMITS, JavaParser.PAREN_S, JavaParser.DECIMAL_LITERAL, JavaParser.HEX_LITERAL, JavaParser.OCT_LITERAL, JavaParser.BINARY_LITERAL, JavaParser.FLOAT_LITERAL, JavaParser.HEX_FLOAT_LITERAL, JavaParser.BOOL_LITERAL, JavaParser.CHAR_LITERAL, JavaParser.STRING_LITERAL, JavaParser.TEXT_BLOCK, JavaParser.NULL_LITERAL, JavaParser.LT, JavaParser.LOG_NOT, JavaParser.TILDE, JavaParser.UNN_INC, JavaParser.UNN_DEC, JavaParser.ADD, JavaParser.SUB, JavaParser.AT, JavaParser.IDENTIFIER]:
                self.state = 1690
                self.expression(0)
                self.state = 1691
                self.match(JavaParser.ARRAY_E)
                self.state = 1698
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,210,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1692
                        self.match(JavaParser.ARRAY_S)
                        self.state = 1693
                        self.expression(0)
                        self.state = 1694
                        self.match(JavaParser.ARRAY_E) 
                    self.state = 1700
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,210,self._ctx)

                self.state = 1705
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,211,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1701
                        self.match(JavaParser.ARRAY_S)
                        self.state = 1702
                        self.match(JavaParser.ARRAY_E) 
                    self.state = 1707
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,211,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_creator_restContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arguments(self):
            return self.getTypedRuleContext(JavaParser.ArgumentsContext,0)


        def class_body(self):
            return self.getTypedRuleContext(JavaParser.Class_bodyContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_class_creator_rest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClass_creator_rest" ):
                listener.enterClass_creator_rest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClass_creator_rest" ):
                listener.exitClass_creator_rest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClass_creator_rest" ):
                return visitor.visitClass_creator_rest(self)
            else:
                return visitor.visitChildren(self)




    def class_creator_rest(self):

        localctx = JavaParser.Class_creator_restContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_class_creator_rest)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1710
            self.arguments()
            self.state = 1712
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,213,self._ctx)
            if la_ == 1:
                self.state = 1711
                self.class_body()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Explicit_generic_invocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def non_wildcard_type_arguments(self):
            return self.getTypedRuleContext(JavaParser.Non_wildcard_type_argumentsContext,0)


        def explicit_generic_invocation_suffix(self):
            return self.getTypedRuleContext(JavaParser.Explicit_generic_invocation_suffixContext,0)


        def getRuleIndex(self):
            return JavaParser.RULE_explicit_generic_invocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplicit_generic_invocation" ):
                listener.enterExplicit_generic_invocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplicit_generic_invocation" ):
                listener.exitExplicit_generic_invocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplicit_generic_invocation" ):
                return visitor.visitExplicit_generic_invocation(self)
            else:
                return visitor.visitChildren(self)




    def explicit_generic_invocation(self):

        localctx = JavaParser.Explicit_generic_invocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_explicit_generic_invocation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1714
            self.non_wildcard_type_arguments()
            self.state = 1715
            self.explicit_generic_invocation_suffix()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[104] = self.expression_sempred
        self._predicates[114] = self.guarded_pattern_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 25)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 24)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 3)
         

    def guarded_pattern_sempred(self, localctx:Guarded_patternContext, predIndex:int):
            if predIndex == 17:
                return self.precpred(self._ctx, 1)
         




